<!DOCTYPE html>
<html lang="en">
<!--
    HOW IT WORKS

    1. A number of classes with names starting with sbitx- are defined these are
    used to implement sbitx specific handlers for events, etc.

    2. A single websocket is used for efficient communication with the sbitx process
    The websocket is used to transmit text messages for UI interactions and a binary
    format for raw audio samples.
    2.1 The audio samples are enabled only for remote login. We do this by detecting if
    the sbitx url is localhost or not.
    2.2 All commands are implemented as fields of UI in sbitx. Read the C source to
    understand those.

    SEMANTIC STRUCTURE

    The top bar has frequency, volume, mode and icons to restore the web ui,
    enable/disable the on-screen keyboard, etc.

    Each mode like ssb, ft8, etc has its own div that is enabled and others are all disabled.

    MAKING YOUR OWN SKINS
    we can use different skins by replacing/editing the index.html and the style.css
    in /home/pi/sbitx/web directory on the sbitx.

    CREDITS:
    The wonderful knob is from https://github.com/aterrien/jQuery-Knob
-->

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>sBitx</title>
    <script src="jquery.min.js"></script>
    <script src="jquery.knob.js"></script>
    <script src="pcm-player.js"></script>
    <script src="nosleep.min.js"></script>
    <script src="proj4.js"></script>
    <script src="gridmap.js"></script>
    <link rel="stylesheet" href="style.css">
    <style>
        #spectrum_header {
            position: relative;
            color: #fff;
            font-family: monospace;
            font-size: 12px;
            margin: 0 2px;
        }
        #spectrum-wrap {
            margin-bottom: 2px;
        }
        .smeter-labels {
            text-shadow: 1px 1px 1px rgba(0, 0, 0, 0.9);
            font-weight: bold;
            letter-spacing: -0.5px;
            margin-top: 3px;
        }
        .smeter-box {
            flex: 1;
            height: 6px;
            background-color: #222;
            border: 1px solid #333;
            transition: background-color 0.15s;
            position: relative;
            overflow: hidden;
        }
        .smeter-box.active {
            background-color: #00ff00;
            box-shadow: 0 0 3px rgba(0, 255, 0, 0.5);
            border-color: #00ff00;
        }
        .smeter-box[data-level="20"].active {
            background-color: #ff0000;
            box-shadow: 0 0 3px rgba(255, 0, 0, 0.5);
            border-color: #ff0000;
        }
        .bottom-bar {
            display: flex;
            position: relative;
            margin-top: 5px;
            gap: 10px;
            justify-content: flex-end;
            width: 100%;
        }
        .mode-panel {
            position: relative;
        }

        .tune-disabled {
            position: relative;
            opacity: 0.6;
            cursor: not-allowed;
        }

        .tune-disabled::before,
        .tune-disabled::after {
            content: '';
            position: absolute;
            top: 0;
            left: 50%;
            width: 1px;
            height: 100%;
            background: red;
        }

        .tune-disabled::before {
            transform: rotate(45deg);
        }

        .tune-disabled::after {
            transform: rotate(-45deg);
        }

        /* Zerobeat indicator styles */
        #zerobeat-container {
            display: none;
            margin: 4px 10px 0;
            text-align: center;
            min-width: 120px;
        }

        .zerobeat-label {
            color: #fff;
            font-size: 12px;
            margin-bottom: 3px;
            text-shadow: 1px 1px 1px rgba(0, 0, 0, 0.9);
            font-weight: bold;
            letter-spacing: -0.5px;
        }

        .zerobeat-boxes {
            display: flex;
            gap: 2px;
            justify-content: center;
        }

        .zerobeat-box {
            width: 15px;
            height: 6px;
            background-color: #222;
            border: 1px solid #333;
            transition: background-color 0.15s;
            position: relative;
            overflow: hidden;
        }

        .zerobeat-box.active[data-level="1"] {
            background-color: #ff0000;
            box-shadow: 0 0 3px rgba(255, 0, 0, 0.5);
            border-color: #ff0000;
        }

        .zerobeat-box.active[data-level="2"] {
            background-color: #ffff00;
            box-shadow: 0 0 3px rgba(255, 255, 0, 0.5);
            border-color: #ffff00;
        }

        .zerobeat-box.active[data-level="3"] {
            background-color: #00ff00;
            box-shadow: 0 0 3px rgba(0, 255, 0, 0.5);
            border-color: #00ff00;
        }

        .zerobeat-box.active[data-level="4"] {
            background-color: #ffff00;
            box-shadow: 0 0 3px rgba(255, 255, 0, 0.5);
            border-color: #ffff00;
        }

        .zerobeat-box.active[data-level="5"] {
            background-color: #ff0000;
            box-shadow: 0 0 3px rgba(255, 0, 0, 0.5);
            border-color: #ff0000;
        }
    </style>
</head>

<body>

    <input type="hidden" id="FREQ" value="7040000">
    <input type="hidden" id="VFOA" value="7040000">
    <input type="hidden" id="VFOB" value="7040000">
    <input type="hidden" id="POWER" value="0">
    <input type="hidden" id="REF" value="1">
    <input type="hidden" id="HIGH" value="2200">
    <input type="hidden" id="LOW" value="300">
    <input type="hidden" id="STATUS" value="---">
    <input type="hidden" id="REC" value="OFF">
    <input type="hidden" id="RIT_DELTA" name="RIT_DELTA" value="">

    <input type="hidden" id="VOLTAGE" value="0">
    <input type="hidden" id="CURRENT" value="0">
    <input type="hidden" id="ZEROBEAT" value="0">
    <input type="hidden" id="ZEROSENSE_hidden" value="5">
    <div id="keypad_panel" class="sbitx-panel" style="display: none;">
        <h2 class="sbitx-panel-title">
            Enter Frequency
            <button class="sbitx-btn-back" data-for="panel_bar">X Close</button>
        </h2>
        <div id="keypad_input">
            <input type="text" id="freq_input" class="sbitx-text-input" placeholder="Enter frequency (kHz)" readonly>
        </div>
        <div id="keypad_buttons">
            <button class="keypad-btn">1</button>
            <button class="keypad-btn">2</button>
            <button class="keypad-btn">3</button>
            <button class="keypad-btn">4</button>
            <button class="keypad-btn">5</button>
            <button class="keypad-btn">6</button>
            <button class="keypad-btn">7</button>
            <button class="keypad-btn">8</button>
            <button class="keypad-btn">9</button>
            <button class="keypad-btn">0</button>
            <button class="keypad-btn">.</button>
            <button class="keypad-btn" id="keypad_clear">Clear</button>
            <button class="keypad-btn" id="keypad_delete">Del</button>
            <button class="keypad-btn" id="keypad_enter">Enter</button>
        </div>
    </div>
    <div id="sdr_page">
        <!-- Battery status bar -->
        <div style="padding: 5px; background: #1a1a1a;">
            <!-- Battery status display if INA260 is equipped -->
            <div id="battery_status" style="display: none; color: white; font-size: 14px;">
                BATT: <span id="voltage_display">0.00V</span> / <span id="current_display">0.00A</span>
            </div>
        </div>

        <section id="maincontrols">
            <div class="sbitxv3-control">
                <label class="sbitxv3-label" for="MODE">MODE</label>
                <select class="sbitxv3-selection sbitx-selection" id="MODE">
                    <option value="USB">USB</option>
                    <option value="LSB">LSB</option>
                    <option value="CW">CW</option>
                    <option value="CWR">CWR</option>
                    <option value="FT8">FT8</option>
                    <option value="FT4">FT4</option>
                    <option value="DIGI">DIGI</option>
                    <option value="2TONE">2TONE</option>
                    <option value="AM">AM</option>
                </select>
            </div>
            <div class="sbitxv3-VFO" id="dial">
                <span id="current_freq">A:00.000.000</span>
                <span id="other_freq">B: 00.000.000</span>
            </div>
            <div class="sbitxv3-control">
                <label class="sbitxv3-label" for="BAND">BAND</label>
                <select class="sbitxv3-selection sbitx-selection" id="BAND">
                    <option value="10M">10M</option>
                    <option value="12M">12M</option>
                    <option value="15M">15M</option>
                    <option value="17M">17M</option>
                    <option value="20M">20M</option>
                    <option value="30M">30M</option>
                    <option value="40M">40M</option>
                    <option value="60M">60M</option>
                    <option value="80M">80M</option>
                </select>
                <!-- <span id="SELBAND" style="display: block;"></span> -->
            </div>
            <button class="sbitxv3-btn" id="STORE" type="button">
                STORE<br/>
                <span id="SELBAND" class="btn-value">=---</span>
            </button>
            <div class="sbitxv3-control rx-control">
                <label class="sbitxv3-label" for="AGC">AGC</label>
                <select class="sbitxv3-selection sbitx-selection" id="AGC">
                    <option value="FAST">FAST</option>
                    <option value="MED">MED</option>
                    <option value="SLOW">SLOW</option>
                    <option value="OFF">OFF</option>
                </select>
            </div>
            <div class="linear rx-control" id="linear_BW">
                <label class="linear-label" for="BW">BW</label>
                <input type="number" id="BW" min="50" max="5000" step="50" class="linear-value">
                <div class="linear-dropdown">
                    <input type="range" class="linear-slider" id="slider_BW" max="5000" min="50" step="50" value="13">
                </div>
            </div>
            <div class="linear rx-control" id="linear_IF">
                <label class="linear-label" for="IF">IF</label>
                <input type="number" id="IF" min="0" max="100" class="linear-value">
                <div class="linear-dropdown">
                    <input type="range" class="linear-slider" id="slider_IF" max="100" min="0" step="1" value="13">
                </div>
            </div>
            <div class="linear rx-control" id="linear_AUDIO">
                <label class="linear-label" for="AUDIO">AUDIO</label>
                <input type="number" id="AUDIO" min="0" max="100" class="linear-value">
                <div class="linear-dropdown">
                    <input type="range" class="linear-slider" id="slider_AUDIO" max="100" min="0" step="1" value="13">
                </div>
            </div>
            <button class="sbitxv3-btn" id="sound_mute" type="button">Mute<br/>
                <span id="mute_state" class="btn-value">OFF</span></button>
            <button class="sbitxv3-btn" id="tune_button" type="button">Tune<br/>
                <span id="tune_state" class="btn-value">&nbsp;</span></button></button>

            <div class="linear" id="linear_BFO">
                <label class="linear-label" for="BFO">BFO</label>
                <input type="number" id="BFO" min="-3000" max="3000" class="linear-value" value="0">
                <div class="linear-dropdown">
                    <input type="range" class="linear-slider" id="slider_BFO" max="3000" min="-3000" step="50" value="0">
                </div>
            </div>

            <div class="linear" id="linear_DRIVE">
                <label class="linear-label" for="DRIVE">DRIVE</label>
                <input type="number" id="DRIVE" min="1" max="100" class="linear-value">
                <div class="linear-dropdown">
                    <input type="range" class="linear-slider" id="slider_DRIVE" max="100" min="1" step="1" value="13">
                </div>
            </div>

            <div class="sbitxv3-control">
                <label class="sbitxv3-label" for="STEP">STEP</label>
                <select id="STEP" class="sbitx-selection sbitxv3-selection">
                    <option value="10H">10H</option>
                    <option value="100H">100H</option>
                    <option value="500H">500H</option>
                    <option value="1K">1K</option>
                    <option value="10K">10K</option>
                    <option value="100K">100K</option>
                </select>
            </div>
            <div class="sbitxv3-control">
                <label class="sbitxv3-label" for="VFO">VFO</label>
                <select class="sbitxv3-selection sbitx-selection" id="VFO">
                    <option value="A">A</option>
                    <option value="B">B</option>
                </select>
            </div>
            <div class="sbitxv3-control">
                <label class="sbitxv3-label" for="SPLIT">SPLIT</label>
                <select class="sbitxv3-selection sbitx-selection" id="SPLIT">
                    <option value="OFF">OFF</option>
                    <option value="ON">ON</option>
                </select>
            </div>
            <div class="sbitxv3-control">
                <label class="sbitxv3-label" for="RIT">RIT</label>
                <select class="sbitxv3-selection sbitx-selection" id="RIT">
                    <option value="OFF">OFF</option>
                    <option value="ON">ON</option>
                </select>
            </div>
            <div class="sbitxv3-control">
                <label class="sbitxv3-label" for="ePTT">ePTT</label>
                <select class="sbitxv3-selection sbitx-selection" id="ePTT">
                    <option value="OFF">OFF</option>
                    <option value="ON">ON</option>
                </select>
            </div>
            <div class="sbitxv3-control">
                <label class="sbitxv3-label" for="SPAN">SPAN</label>
                <select class="sbitxv3-selection sbitx-selection" id="SPAN">
                    <option value="25K">25K</option>
                    <option value="10K">10K</option>
                    <option value="6K">6K</option>
                    <option value="2.5K">2.5K</option>
                </select>
            </div>
            <div class="linear cw-ft8-control" id="linear_SIDETONE">
                <label class="linear-label" for="SIDETONE">SIDETN</label>
                <input type="number" id="SIDETONE" min="0" max="100" class="linear-value">
                <div class="linear-dropdown">
                    <input type="range" class="linear-slider" id="slider_SIDETONE" max="100" min="0" step="5"
                        value="0">
                </div>
             </div>
        </section>
        <section id="logger-controls" class="sbitx-panel">
            <button class="sbitxv3-btn" id="qrz">?</button>
            <input type="text" class="logger-input sbitx-text-input sbitx-text-field" id="CALL" placeholder="Call">
            <input type="text" class="logger-input sbitx-text-input sbitx-text-field" id="SENT" placeholder="Sent">
            <input type="text" class="logger-input sbitx-text-input sbitx-text-field" id="RECV" placeholder="Rcv">
            <input type="text" class="logger-input sbitx-text-input sbitx-text-field" id="EXCH" placeholder="Exch">
            <input type="text" class="logger-input sbitx-text-input sbitx-text-field" id="NR" placeholder="Nr">
            <button class="sbitxv3-btn" id="logger-log">OK</button>
            <button class="sbitxv3-btn" id="wipe">WIPE</button>
            <button class="sbitxv3-btn" id="logbook-open">LOG</button>
        </section>
        <button id="restore-btn" onclick="toggle_fullscreen();">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2">
                <path d="M12 5v14M5 12h14M7 7l5 5m5-5l-5 5" />
            </svg>
        </button>
        <main id="main">

            <!-- logbook -->
            <div id="logbook_panel" class="sbitx-panel">
                <input class="logger-input sbitx-text-input sbitx-text-field" id="logbook-search" type="text" size="6"
                    placeholder="Search" />
                <button class="sbitxv3-btn longer-control" id="btn-logbook-load">More</button>
                <button class="sbitxv3-btn longer-control" id="btn-logbook-close">Close</button>
                <table id="logbook_table">
                    <thead>
                        <tr>
                            <th class="logbook-serial">#</th>
                            <th class="logbook-datestamp">Date-Time</th>
                            <th class="logbook-freq">Freq</th>
                            <th class="logbook-mode">Mode</th>
                            <th class="logbook-call">Call</th>
                            <th class="logbook-sent">Sent</th>
                            <th class="logbook-recv">Recv</th>
                        </tr>
                    </thead>
                    <tbody>
                    </tbody>
                </table>
            </div>

            <!-- pan adapter and waterfall -->
            <section id="pan_adapter">
                <div id="spectrum_header" style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 4px; min-height: 24px;">
                    <!-- S-meter display -->
                    <div id="smeter_display" style="width: 120px; margin-top: 4px;">
                        <div class="smeter-boxes" style="display: flex; gap: 2px; height: 8px; margin-bottom: 2px;">
                            <div class="smeter-box" data-level="1"></div>
                            <div class="smeter-box" data-level="3"></div>
                            <div class="smeter-box" data-level="5"></div>
                            <div class="smeter-box" data-level="7"></div>
                            <div class="smeter-box" data-level="9"></div>
                            <div class="smeter-box" data-level="20"></div>
                        </div>
                        <div class="smeter-labels" style="display: flex; font-size: 10px;">
                            <div style="flex: 1; text-align: center;">1</div>
                            <div style="flex: 1; text-align: center;">3</div>
                            <div style="flex: 1; text-align: center;">5</div>
                            <div style="flex: 1; text-align: center;">7</div>
                            <div style="flex: 1; text-align: center;">9</div>
                            <div style="flex: 1; text-align: center;">+20</div>
                        </div>
                    </div>
                    <!-- Zerobeat indicator -->
                    <div id="zerobeat-container" style="position: absolute; left: 50%; transform: translateX(-50%);">
                        <div class="zerobeat-boxes" style="margin-bottom: 2px;">
                            <div class="zerobeat-box" data-level="1"></div>
                            <div class="zerobeat-box" data-level="2"></div>
                            <div class="zerobeat-box" data-level="3"></div>
                            <div class="zerobeat-box" data-level="4"></div>
                            <div class="zerobeat-box" data-level="5"></div>
                        </div>
                        <div class="zerobeat-label smeter-labels" style="text-align: center;">Zero Beat</div>
                    </div>
                    <!--<div id="console" style="width: autoxt-align: left; margin-top: 4px;">Hello</div>-->
                </div>
                <div id="tx_meters">
                    <div class="menu-item">
                        <label class="slider-label" for="POWER_meter">Watts</label>
                        <meter id="POWER_meter" max="500" min="0" value="0"></meter>
                        <span id="POWER_reading"></span>
                    </div>
                    <div class="menu-item">
                        <label class="slider-label" for="REF_meter">SWR</label>
                        <meter id="REF_meter" max="1000" min="0" value="0"></meter>
                        <span id="REF_reading"></span>
                    </div>
                </div>

                <div id="spectrum-wrap" style="position: relative; border: 2px solid #333; border-radius: 4px; padding: 0px; background: #1a1a1a; box-shadow: inset 0 0 2px rgba(0,0,0,0.5);">
                    <canvas id="spectrum" width="600" height="80"></canvas>
                </div>
                <canvas id="waterfall" width="600" height="80"></canvas>
            </section>
            <!-- wsjtx specific controls -->
            <section id="FT8_ui" class="sbitx-panel mode-panel">
                <div id="wsjtx-activity" class="sbitx-list-container">
                    Band Activity
                    <ol class="sbitx-list-box"></ol>
                </div>
                <div id="wsjtx-rx" class="sbitx-list-container">
                    QSOs
                    <ol class="sbitx-list-box"></ol>
                </div>
                <div id="gridmap"></div>
                <div id="FT8_controls">
                    <div class="sbitxv3-control">
                        <label class="sbitxv3-label" for="FTX_CQ">CQ</label>
                        <select class="sbitxv3-selection sbitx-selection" id="FTX_CQ">
                            <option value="EVEN">EVEN</option>
                            <option value="ODD">ODD</option>
                            <option value="ALT_EVEN">ALT</option>
                            <option value="XOTA">xOTA</option>
                        </select>
                    </div>
                    <div class="sbitxv3-control">
                        <label class="sbitxv3-label" for="FTX_AUTO">AUTO</label>
                        <select class="sbitxv3-selection sbitx-selection" id="FTX_AUTO">
                            <option value="OFF">OFF</option>
                            <option value="ANS">ANS</option>
                            <option value="CQRESP">CQRESP</option>
                        </select>
                    </div>
                    <div class="linear" id="linear_FTX_REPEAT">
                        <label class="linear-label" for="FTX_REPEAT">REPEAT</label>
                        <input type="number" id="FTX_REPEAT" min="1" max="10" class="linear-value">
                        <div class="linear-dropdown">
                            <input type="range" class="linear-slider" id="slider_FTX_REPEAT" max="10" min="1" step="1"
                                value="3">
                        </div>
                    </div>
                    <div class="linear" id="linear_TX_PITCH">
                        <label class="linear-label" for="TX_PITCH">TX TONE</label>
                        <input type="number" id="TX_PITCH" min="10" max="4000" class="linear-value">
                        <div class="linear-dropdown">
                            <input type="range" class="linear-slider" id="slider_TX_PITCH" max="4000" min="10" step="10"
                                value="1900">
                        </div>
                    </div>
                    <div class="bottom-bar">
                        <button class="sbitxv3-btn" id="xpra_launch_ft8" type="button">Apps</button>
                        <button class="sbitxv3-btn" id="menu-open">Menu</button>
                   </div>
                </div>

            </section>
            <!-- cw pane -->
            <section id="CW_ui" class="sbitx-panel mode-panel">
                <div id="data_window" tabindex="0">
                    <span id="text_done"></span>
                    <span id="text_pending"></span>
                </div>
                <div id="cw_settings">
                    <div class="linear" id="linear_WPM">
                        <label class="linear-label" for="WPM">WPM</label>
                        <input type="number" id="WPM" min="0" max="100" class="linear-value">
                        <div class="linear-dropdown">
                            <input type="range" class="linear-slider" id="slider_WPM" max="40" min="5" step="1"
                                value="13">
                        </div>
                    </div>
                    <div class="linear" id="linear_PITCH">
                        <label class="linear-label" for="PITCH">PITCH</label>
                        <input type="number" id="PITCH" min="0" max="100" class="linear-value">
                        <div class="linear-dropdown">
                            <input type="range" class="linear-slider" id="slider_PITCH" max="3000" min="50" step="10"
                                value="600">
                        </div>
                    </div>
                    <div class="linear" id="linear_CW_DELAY">
                        <label class="linear-label" for="CW_DELAY">DELAY</label>
                        <input type="number" id="CW_DELAY" min="50" max="1000" class="linear-value">
                        <div class="linear-dropdown">
                            <input type="range" class="linear-slider" id="slider_CW_DELAY" max="1000" min="50" step="50"
                                value="600">
                        </div>
                    </div>

                    <div class="linear" id="linear_CW_INPUT">
                        <label class="linear-label" for="CW_INPUT">INPUT</label>
                        <select class="sbitxv3-selection sbitx-selection" id="CW_INPUT">
                            <option value="IAMBIC">IAMBIC</option>
                            <option value="IAMBICB">IAMBIC-B</option>
                            <option value="STRAIGHT">STRAIGHT</option>
                            <option value="BUG">BUG</option>
                            <option value="ULTIMAT">ULTIMATIC</option>
                        </select>
                    </div>

                    <div class="bottom-bar">
                        <button class="sbitxv3-btn" id="xpra_launch_cw" type="button">Apps</button>
                        <button class="sbitxv3-btn" id="menu-open2">Menu</button>
                    </div>
                </div>
                <div id="data_chat">
                    <button id="data_chat_tx">TX</button>
                    <button id="data_chat_rx">RX</button>
                </div>

            </section>
            <!-- ssb/2tone pane -->
            <section id="digi_ui" class="sbitx-panel mode-panel">
                <div class="bottom-bar">
                    <button class="sbitxv3-btn" id="xpra_launch_digi" type="button">Apps</button>
                    <button class="sbitxv3-btn" id="menu-open4">Menu</button>
                </div>
            </section>
            <section id="Voice_ui" class="sbitx-panel mode-panel">
                <div class="linear" id="linear_MIC">
                    <label class="linear-label" for="MIC">MIC</label>
                    <input type="number" id="MIC" min="0" max="100" class="linear-value">
                    <div class="linear-dropdown">
                        <input type="range" class="linear-slider" id="slider_MIC" max="100" min="0" step="1" value="13">
                    </div>
                </div>
                <div class="sbitxv3-control">
                    <label class="sbitxv3-label" for="DSP">DSP</label>
                    <select class="sbitxv3-selection sbitx-selection" id="DSP">
                        <option value="OFF">OFF</option>
                        <option value="ON">ON</option>
                    </select>
                </div>
                <div class="sbitxv3-control">
                    <label class="sbitxv3-label" for="ANR">ANR</label>
                    <select class="sbitxv3-selection sbitx-selection" id="ANR">
                        <option value="OFF">OFF</option>
                        <option value="ON">ON</option>
                    </select>
                </div>
                <div class="sbitxv3-control">
                    <label class="sbitxv3-label" for="RXEQ">RXEQ</label>
                    <select class="sbitxv3-selection sbitx-selection" id="RXEQ">
                        <option value="OFF">OFF</option>
                        <option value="ON">ON</option>
                    </select>
                </div>
                <div class="sbitxv3-control">
                    <label class="sbitxv3-label" for="TXEQ">TXEQ</label>
                    <select class="sbitxv3-selection sbitx-selection" id="TXEQ">
                        <option value="OFF">OFF</option>
                        <option value="ON">ON</option>
                    </select>
                </div>
                <div class="linear rx-control" id="compresseion">
                    <label class="linear-label" for="COMP">COMP</label>
                    <input type="number" id="COMP" min="0" max="10" class="linear-value">
                    <div class="linear-dropdown">
                        <input type="range" class="linear-slider" id="slider_COMP" max="10" min="0" step="1" value="5">
                    </div>
                </div>
                <button id="ptt_tx">TX</button>
                <button id="ptt_rx">RX</button>
                <button class="sbitxv3-btn" id="browser_mic" type="button" onclick="toggleBrowserMic()">Browser Mic<br>OFF</button>
                <div class="bottom-bar">
                   <button class="sbitxv3-btn" id="xpra_launch_voice" type="button">Apps</button>
                    <button class="sbitxv3-btn" id="menu-open3">Menu</button>
                </div>
            </section>

        </main>
    </div>


    <div id="more_keys">
        <div class="sbitxv3-MACRO">
            <label class="sbitxv3-label" for="MACRO">MACRO</label>
            <select class="sbitxv3-selection sbitx-selection" id="MACRO"></select>
        </div>
        <button class="sbitxv3-btn" id="esc">ESC</button>
        <button class="sbitxv3-btn macro-btn" id="F1">F1</button>
        <button class="sbitxv3-btn macro-btn" id="F2">F2</button>
        <button class="sbitxv3-btn macro-btn" id="F3">F3</button>
        <button class="sbitxv3-btn macro-btn" id="F4">F4</button>
        <button class="sbitxv3-btn macro-btn" id="F5">F5</button>
        <button class="sbitxv3-btn macro-btn" id="F6">F6</button>
        <button class="sbitxv3-btn macro-btn" id="F7">F7</button>
        <button class="sbitxv3-btn macro-btn" id="F8">F8</button>
        <button class="sbitxv3-btn macro-btn" id="F9">F9</button>
        <button class="sbitxv3-btn macro-btn" id="F10">F10</button>
    </div>

    <!-- menu panel -->
    <section id="menu_panel" class="sbitx-panel">
        <h2 class="sbitx-panel-title">
            Menu
            <button class="sbitx-btn-back" data-for="panel_bar">X Close</button>
        </h2>
        <button class="sbitxv3-btn" id="console-open">CMD</button>
        <button class="sbitxv3-btn" id="telnet-open">TEL</button>
        <button class="sbitxv3-btn" id="recorder-open">REC</button>
        <button class="sbitxv3-btn" id="settings-open">SET</button>
    </section>
    <!-- console panel -->
    <section id="console_panel" class="sbitx-panel">
        <h2 class="sbitx-panel-title">
            Terminal
            <button class="sbitx-btn-back" data-for="panel_bar">X Close</button>
        </h2>
        <div id="console_window"></div>
        <div class="console-help-text" style="color: #aaa; font-size: 0.9em; margin: 5px 0; padding: 0 5px;">Enter terminal commands without leading backslash. i.e. ANR ON</div>
        <div id="command_bar">
            <input type="text" class="sbitx-text-input" id="text_in" placeholder="Enter command without backslash...">
        </div>
    </section>
    <!-- telnet panel -->
    <section id="telnet_panel" class="sbitx-panel">
        <h2 class="sbitx-panel-title">
            Telnet
            <button class="sbitx-btn-back" data-for="panel_bar">X Close</button>
        </h2>
        <button id="telnet" class="logger-button sbitx-btn">Start</button>
        <button id="tclose" class="logger-button sbitx-btn">Stop</button>
        <div id="telnet_window"></div>
        <div id="telnet_command_bar">
            <input type="text" class="sbitx-text-input" id="telnet_in">
        </div>
    </section>
    <!-- settings panel -->
    <section id="settings_panel" class="sbitx-panel">
        <h2 class="sbitx-panel-title" style="display: flex; align-items: center; width: 100%;">
            Settings
            <button class="sbitx-btn-back" data-for="panel_bar">X Close</button>
        </h2>
        <div>
            <label class="settings-label" for="PASSKEY">Passkey:</label>
            <input id="PASSKEY" class="settings_input sbitx-text-input" type="text">
        </div>
        <div class="settings-element">
            <label class="settings-label" for="MYCALLSIGN">My Callsign:</label>
            <input id="MYCALLSIGN" class="settings_input sbitx-text-input" type="text">
        </div>
        <div class="settings-element">
            <label class="settings-label" for="MYGRID">My Grid:</label>
            <input id="MYGRID" class="settings_input sbitx-text-input" type="text">
        </div>
        <div class="settings-element">
            <label class="settings-label" for="TELNETURL">Telnet Server:</label>
            <input type="text" class="settings_input sbitx-text-input" id="TELNETURL"
                placeholder="e.g., dxc.nc7j.com:7373">
        </div>
        <div class="settings-element">
            <button id="settings_save" class="logger-button">Update</button>
        </div>

    </section>
    <!-- login panel -->
    <section id="login_panel">
        <div class="help_text">
            <h1>sbitx v5.0</h1>
            <p>The sBitx is an open-source, hackable, next generation tranceiver.</p>
            <p>Enter passkey to access your sbitx.</p>
            <div id="login_error"></div>
            <input type="text" class="sbitx-text-input" id="passkey" name="passkey" autocomplete="off"
                placeholder="passkey">
            <button class="sbitxv3-btn" id="start_login">Start</button>
            <p>New user? Try 123 as the passkey. Change it when prompted.</p>
            <p>
                Released under General Public License v3.0.<br>
                (c) Ashhar Farhan, 2023 forked by the 64Bit Development Group, 2025.
            </p>

            <canvas id="canvas" width="350" height="120"></canvas>
            <script>
                const canvas = document.getElementById('canvas');
                const ctx = canvas.getContext('2d');
                const text_animation = "sBitx 64bit";
                const fontSize = 60;
                let letters = [];
                let time = 0;

                class Letter {
                    constructor(char, x, y, delay) {
                        this.char = char;
                        this.x = x;
                        this.y = y;
                        this.delay = delay;
                        this.opacity = 0;
                    }

                    update() {
                        if (time >= this.delay) {
                            this.opacity = Math.min(this.opacity + 0.015, 1); // Smooth fade-in
                        }
                    }

                    draw() {
                        ctx.save();
                        ctx.globalAlpha = this.opacity;
                        ctx.font = `${fontSize}px Arial`;
                        ctx.fillStyle = '#D3D3D3'; // White/grey color
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(this.char, this.x, this.y);
                        ctx.restore();
                    }
                }

                function init() {
                    ctx.font = `${fontSize}px Arial`;
                    const textWidth = ctx.measureText(text_animation).width;
                    const startX = canvas.width / 2 - textWidth / 2;
                    let x = startX;

                    for (let i = 0; i < text_animation.length; i++) {
                        const metrics = ctx.measureText(text_animation[i]);
                        x += metrics.width / 2;
                        letters.push(new Letter(text_animation[i], x, canvas.height / 2, i * 15));
                        x += metrics.width / 2;
                    }
                }

                function animate() {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    letters.forEach(letter => {
                        letter.update();
                        letter.draw();
                    });
                    time++;
                    requestAnimationFrame(animate);
                }

                init();
                animate();
            </script>
            <p>
                Join our Discord at <a href="https://discord.gg/tCCjw5g5Pf">https://discord.gg/tCCjw5g5Pf</a>
            </p>
        </div>
    </section>
    <!-- recorder panel -->
    <div id="recorder_panel" class="sbitx-panel mode-panel">
        <h2 class="sbitx-panel-title">
            <button class="sbitx-btn-back" data-for="panel_bar">X Close</button>
        </h2>
        <div class="menu_item">
            <button class="logger-button" id="record_start">REC</button>
            <button class="logger-button" id="record_stop">STOP</button>

        </div>
        <span id="record_duration">00:00</span>

    </div>
</body>

<script>

    var in_tx = false;
    var isTuneOn = false;
    var parser = null;
    var qrz_window = null;
    var log_window = null;
    var session_id = "nullsession";
    var macros_file = "";
    var current_macro = "";
    var spots = null;
    var logbook_bottom_row_id = -1;
    var logbook_top_row_id = 0;
    var sound_mute = false;
    var curBand = "";
    var band_stack_indicators = ["", "", "", "", "", "", "", "", ""];

    /* oz7bx gridmap */
    GRIDMAP.init(document.getElementById("gridmap"), 360, 360);

    // Keypad functionality
    function show_keypad() {
        $("#keypad_panel").show();
        el("freq_input").value = "";
        el("freq_input").focus();
    }

    function hide_keypad() {
        $("#keypad_panel").hide();
        el("freq_input").value = "";
    }

    // Handle keypad button clicks
    function keypad_button_clicked(event) {
        var btn = event.currentTarget;
        var input = el("freq_input");
        var currentValue = input.value;

        if (btn.id === "keypad_clear") {
            input.value = "";
        } else if (btn.id === "keypad_delete") {
            input.value = currentValue.slice(0, -1);
        } else if (btn.id === "keypad_enter") {
            submit_frequency();
        } else {
            // Append the button's value (number or decimal point)
            var newChar = btn.innerHTML;
            // Prevent multiple decimal points
            if (newChar === "." && currentValue.includes(".")) {
                return;
            }
            input.value = currentValue + newChar;
        }
    }

    // Validate and submit the frequency
    function submit_frequency() {
        var input = el("freq_input").value;
        // Remove any trailing decimal point
        if (input.endsWith(".")) {
            input = input.slice(0, -1);
        }
        // Validate input: must be a number, optionally with one decimal point
        if (!/^\d+(\.\d{0,3})?$/.test(input)) {
            alert("Please enter a valid frequency in kHz (e.g., 7.040 or 14.0745)");
            return;
        }
        // Convert kHz to Hz (multiply by 1000)
        var freqHz = Math.round(parseFloat(input) * 1000);
        // Basic validation: ensure frequency is within a reasonable range (e.g., 1 MHz to 30 MHz)
        if (freqHz < 1000000 || freqHz > 30000000) {
            alert("Frequency must be between 1 MHz and 30 MHz.");
            return;
        }
        // Update the frequency using the existing update_freq function
        update_freq(freqHz.toString());
        hide_keypad();
    }

    // Attach event handlers for keypad
    $("#dial").on("click", show_keypad);
    $(".keypad-btn").on("click", keypad_button_clicked);
    $("#keypad_panel .sbitx-btn-back").on("click", hide_keypad);

    /* a few helper functions */
    function el(element_id) {
        return document.getElementById(element_id);
    }

    function log(str) {
        console.log(str);
    }

    function isdigit(str) {
        if (isNaN(str[0]))
            return false;
        else
            return true;
    }

    /* socket handlers */
    var socket = null;

    // Helper function to determine if we're using HTTPS
    function isSecureConnection() {
        return window.location.protocol === 'https:';
    }

    // Helper function to get the correct WebSocket protocol (ws:// or wss://)
    function getWebSocketProtocol() {
        return isSecureConnection() ? 'wss://' : 'ws://';
    }

    // Helper function to get the correct port
    function getWebSocketPort() {
        return isSecureConnection() ? '8443' : '8080';
    }

    // Helper function to get the correct WebSocket path
    function getWebSocketPath() {
        return '/websocket';
    }

    function on_open(event) {
        log("socket is connected");
        websocket_send("login=" + el("passkey").value);
    }

    function on_close(event) {
        log("socket was closed by the radio");
        end_login("Connection lost");
    }

    function on_message(event) {
        response_handler(event.data);
    }

    function websocket_send(str) {
        if (socket == null)
            return;

        var request = session_id + "\n" + str;
        // Add debug logging for all websocket messages
        //console.log("Websocket sending: [" + str + "]");
        socket.send(request);

        // Check if this is a mode change message
        if (str.startsWith("MODE ")) {
            var mode = str.split(" ")[1];
            if ((mode === "FT8" || mode === "FT4" || mode === "DIGI") && window.sbitxMic && window.sbitxMic.enabled) {
                toggleBrowserMic(); // Turn off browser mic
            }
        }
    }

    function on_error(event) {
        log("socket communication error, resetting now");
        if (socket != null)
            socket.close();
        socket = null;
        session_id = "nullsession";
        log("on_error: session_id set to " + session_id);
        show_login();
    }

    /* login handler */
    function end_login(reason) {
        socket = null;
        session_id = "nullsession";
        log("end_login called:" + reason);
        $("#login_error").innerHTML = reason;
        show_login();
    }

    function go_fullscreen() {
        var elem = document.documentElement;
        if (elem.requestFullscreen) {
            elem.requestFullscreen();
        } else if (elem.webkitRequestFullscreen) { /* Safari */
            elem.webkitRequestFullscreen();
        } else if (elem.msRequestFullscreen) { /* IE11 */
            elem.msRequestFullscreen();
        }
    }

    function passkey_keydown(event) {
        if (event.key === 'Enter') {
            // Prevent the default action (e.g., form submission if the input is inside a form)
            event.preventDefault();
            do_login()
        }
    }

    // Existing do_login (modified to call audio_start correctly)
    function do_login() {
        log("requesting full screen");
        if (document.location.hostname == "127.0.0.1") {
            go_fullscreen();
        }

        // Check passkey for non-local connections
        if (el("passkey").value.length < 3 && document.location.hostname != "127.0.0.1") {
            alert("Enter the passkey (three characters or more)");
            return false;
        }

        if (socket != null) {
            socket.close();
            socket = null;
        }

        // Use the helper functions to determine protocol and port
        var wsProtocol = getWebSocketProtocol();
        var wsPort = getWebSocketPort();
        var wsPath = getWebSocketPath();
        var hostname = window.location.hostname;
        if (hostname == "") {
            hostname = "localhost";
        }

        var wsUrl = wsProtocol + hostname + ":" + wsPort + wsPath;

        log("opening socket to " + wsUrl);
        try {
            socket = new WebSocket(wsUrl);
            socket.binaryType = "arraybuffer";
            socket.onopen = on_open;
            socket.onclose = on_close;
            socket.onmessage = on_message;
            socket.onerror = on_error;

            // Start audio for non-local connections
            if (document.location.hostname != "127.0.0.1") {
                audio_start();
            }
        } catch (e) {
            log("socket error: " + e);
            end_login("Failed to connect to sBitx");
        }
    }



    // ui panel switchers
    function show_login() {
        $("#login_panel").show();
        $(".sbitx-panel").hide();
        $("#pan_adapter").hide();
        $("#cmd").hide();
        $("#more_keys").hide();
        $("#maincontrols").hide();
        $("#logger-controls").hide(); // Hide logger controls on login
        if (document.location.hostname == "127.0.0.1")
            show_keyboard();

        // This is a hack to make the onscreen keyboard work with the passkey
        text_focus = el("passkey");
        el("passkey").value = "";
        $("#passkey").focus();
        el("passkey").addEventListener('keydown', passkey_keydown);
    }

    function show_main() {
        var main = el("main");
        main.style.marginLeft = 0; // No sidebar, so no margin
        $("#pan_adapter").show();
        $("#login_panel").hide();
        $("#more_keys").show();
        $("#maincontrols").show();
        $("#logger-controls").show();
        websocket_send("logbook=-1");
        websocket_send("macros_list=macros_list");
    }

    function toggle_fullscreen() {
        if (document.fullscreenElement != null) {
            if (document.exitFullscreen)
                document.exitFullscreen();
            else
                document.documentElement.exitFullscreen();
        }
        else
            document.documentElement.requestFullscreen();
    }

    function freq2str(freq) {
        return freq.substring(0, freq.length - 6) + '.'
            + freq.substring(freq.length - 6, freq.length - 3)
            + '.' + freq.substring(freq.length - 3);
    }


    function draw_meters(event) {
        var power = parseInt(el("POWER").value);
        var ref = parseInt(el("REF").value);

        if (power == 0)
            ref = 10;

        el("POWER_meter").value = power;
        el("POWER_reading").innerHTML = (power / 10).toFixed(0);

        el("REF_meter").value = ref;
        el("REF_reading").innerHTML = (ref / 10).toFixed(1);
    }


    function update_freq(freq) {
        websocket_send("freq " + freq);
    }

    /* All tuning related functions including the soft-kob, drawing the dial etc. */


    function vfo_set(event) {
        var vfo_a = el("VFOA").value;
        var vfo_b = el("VFOB").value;
        var vfo = el("VFO").value; //which one is used?
        var f = el("FREQ").value;

        var btn_id = event.currentTarget.id;

        if (btn_id == 'vfo_reset') {
            if (vfo == 'A')
                vfo_b = vfo_a;
            else
                vfo_a = vfo_b;
        }
        else if (btn_id == "vfo_swap") {
            var swap = vfo_a;
            vfo_a = vfo_b;
            vfo_b = swap;
        }
        websocket_send("VFOB " + vfo_b);
        websocket_send("VFOA " + vfo_a);
        el("VFOA").value = vfo_a;
        el("VFOB").value = vfo_b;
        if (vfo == 'A')
            websocket_send("FREQ " + vfo_a);
        else
            websocket_send("FREQ " + vfo_b);
        draw_dial();
    }

    //draw_dial is called after setting FREQ to the current freq
    function draw_dial() {
        var freq = el("FREQ").value;
        var split = el("SPLIT").value;
        var rit = el("RIT").value;
        var vfo_a = el("VFOA").value;
        var vfo_b = el("VFOB").value;
        var vfo = el("VFO").value; //which one is used?
        var rit_delta = el("RIT_DELTA").value;

        if (rit == "ON") {
            if (in_tx == 1) {
                el("current_freq").innerHTML = "TX&nbsp;" + freq2str(freq);
                el("other_freq").innerHTML =
                    "RX&nbsp;" + freq2str((parseInt(freq) + parseInt(rit_delta)).toString());
            }
            else {
                el("current_freq").innerHTML =
                    "RX&nbsp;" + freq2str((parseInt(freq) + parseInt(rit_delta)).toString());
                el("other_freq").innerHTML = "TX&nbsp;" + freq2str(freq);
            }
        }
        else if (split == "ON") {
            if (in_tx == 0) {
                el("current_freq").innerHTML = "RX&nbsp;" + freq2str(freq);
                el("other_freq").innerHTML = "TX&nbsp;" + freq2str(vfo_b);
            }
            else {
                el("current_freq").innerHTML = "TX&nbsp;" + freq2str(vfo_b);
                el("other_freq").innerHTML = "RX&nbsp;" + freq2str(freq);

            }
        }
        else if (vfo == 'A') {
            if (!in_tx) {
                el("current_freq").innerHTML = "A&nbsp;" + freq2str(freq);
                el("other_freq").innerHTML = "B&nbsp;" + freq2str(vfo_b);
            } else {
                el("current_freq").innerHTML = "TX&nbsp;" + freq2str(vfo_a);
                el("other_freq").innerHTML = "B&nbsp;" + freq2str(freq);
            }
        }
        else if (vfo == 'B') {
            if (!in_tx) {
                el("current_freq").innerHTML = "B&nbsp;" + freq2str(freq);
                el("other_freq").innerHTML = "A&nbsp;" + freq2str(vfo_a);
            } else {
                el("current_freq").innerHTML = "TX&nbsp;" + freq2str(freq);
                el("other_freq").innerHTML = "A&nbsp;" + freq2str(vfo_a);
            }
        }
    }



    /*
        TUNING PANEL
        This handles all frequency changing related functionality
        like RIT, SPLIT, etc.
    */

    let tuning_position_last = 0;
    var knob_resolution = 6;

    function getStepSize() {
        var step_text = el("STEP").value;
        var step_size = 1000;
        switch (step_text) {
            case "10H": step_size = 10; break;
            case "100H": step_size = 100; break;
            case "500H": step_size = 500; break;
            case "1K": step_size = 1000; break;
            case "10K": step_size = 10000; break;
            case "100K": step_size = 100000; break;
        }
        return step_size;
    }
    function tuning_knob_handler(position_now) {
        //avoid small movements
        if (Math.abs(position_now - tuning_position_last) < knob_resolution)
            return;

        //calculate the relative movement of the dial knob
        var delta = 0;
        //we reduce the granulity of the step
        if (position_now < 90 && tuning_position_last > 270)
            delta = position_now + 360.0 - tuning_position_last;
        else if (position_now > 270 && tuning_position_last < 90)
            delta = tuning_position_last + 360 - position_now;
        else
            delta = position_now - tuning_position_last;

        tuning_position_last = position_now;

        //reduce the precision of delta
        delta = Math.round(delta / knob_resolution);
        //tuning up or down by the step value
        var step_size = getStepSize();

        f = el('FREQ');
        var freq = parseInt(f.value);
        freq = Math.round(freq / step_size) * step_size;
        if (delta > 0)
            delta = step_size;
        else
            delta = -step_size;
        f.value = freq + delta;
        update_freq(f.value);
    }

    //initialization code

    //link the knob to the jquery code
    $(function ($) {
        $('.knob').knob({
            width: 150,
            height: 150,
            fgColor: '#1a75ff', // --accent-blue
            bgColor: '#444444', // Slightly lighter for visibility
            thickness: 0.4,
            cursor: 20,
            lineCap: 'round',
            displayInput: false, // No numbers
            step: 0.1, // Fine steps for smooth tuning
            font: 'Helvetica, sans-serif',
            fontWeight: 'normal',
            change: function (value) {
                console.log('Knob changed to:', value);
                tuning_knob_handler(value);
            },
            release: function (value) {
                console.log('Knob released at:', value);
                tuning_knob_handler(value);
            },
            cancel: function () {
                console.log('Knob cancelled');
            },
            draw: function () {
                // Custom draw for gradient
                var ctx = this.g;
                var gradient = ctx.createLinearGradient(0, 0, this.w, this.h);
                gradient.addColorStop(0, '#1a75ff'); // --accent-blue
                gradient.addColorStop(1, '#0d47a1'); // Darker blue
                ctx.strokeStyle = gradient;
            }
        });
        console.log('Knob initialized for #tuning_knob:', $('#tuning_knob').length);
    });
    function change_freq(event) {
        event.preventDefault();
        let f = el('FREQ');
        var freq = parseInt(f.value);
        var step_size = getStepSize();
        freq = Math.round(freq / step_size) * step_size;
        if (event.deltaY > 0)
            freq += step_size;
        else
            freq -= step_size;
        f.value = freq;
        update_freq(f.value);
    }

    /* waterfall and spectrum */

    function resize_ui() {
        var b = $("body");
        log("resize_ui w = " + b.width() + " h = " + b.height());
        el("pan_adapter").width = b.width() - 30;
        el("waterfall").width = b.width() - 30;
        el("spectrum").width = el("waterfall").width;
        $(".sbitx-panel").width = b.width() - 30;
        el("CW_ui").width = b.width() - 30;
        if (el("FT8_controls")) {
            el("FT8_controls").style.width = b.width() + "px"; // Ensure FT8_controls spans full width
        }
        if (el("sbitx-list-container")) {
            el("sbitx-list-container").style.width = "360px"; // Match css style
        }
        /* if(b.height() > 600){
            el("waterfall").height = b.height() / 4;
            el("spectrum").height = b.height() / 4;
        } */
        height = b.height();
    }

    var waterfall_image = null;

    function waterfall_init() {
        var w = el("waterfall");
        var ctx = w.getContext("2d");
        var waterfall_image = ctx.createImageData(w.width, w.height);
        i = 0;
        for (var y = 0; y < w.height; y++) {
            for (var x = 0; x < w.width; x++) {
                waterfall_image.data[i++] = (256 * y) / w.height;
                waterfall_image.data[i++] = (256 * x) / w.width;
                waterfall_image.data[i++] = 0;
                waterfall_image.data[i++] = 255;
            }
        }
        ctx.putImageData(waterfall_image, 0, 0);
    }

    // created by OZ7BX
    function getMousePosition(canvas, event) {
        let rect = canvas.getBoundingClientRect();
        let x = event.clientX - rect.left;
        let w = rect.width;
        console.log("waterfall click " + x + ", " + w);
        let freq = parseInt(el('FREQ').value);
        let span = parseFloat(el('SPAN').value) * 1000;
        freq = Math.round((freq - span / 2 + (span / w) * x) / 100) * 100;
        console.log("waterfall freq " + freq);
        update_freq(freq);
    }

    // Waterfall and filter drag handling
    let isFilterDragging = false; // Flag to indicate if a filter edge is being dragged
    let filterDragEdge = null; // Which edge is being dragged ('left' or 'right')
    let isDragging = false; // Flag to indicate if waterfall is being dragged
    let lastX = 0; // Last X position for calculating drag delta
    let lastTime = 0; // Last time for calculating drag speed
    let lastUpdateTime = 0; // Track time of last frequency update
    const FILTER_EDGE_DETECTION_WIDTH = 40; // Width in pixels for the filter edge detection area

    // Function to get the canvas coordinates from client coordinates
    function getCanvasCoordinates(clientX, clientY, canvas) {
        const rect = canvas.getBoundingClientRect();

        // Calculate the ratio between the canvas's internal dimensions and its display dimensions
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;

        // Convert client coordinates to canvas coordinates
        const canvasX = (clientX - rect.left) * scaleX;
        const canvasY = (clientY - rect.top) * scaleY;

        // Store the current scale factors for reference
        window.currentScaleX = scaleX;
        window.currentScaleY = scaleY;

        return { x: canvasX, y: canvasY };
    }

    // Function to get the appropriate edge detection width based on device
    function getEdgeDetectionWidth(isTouch = false) {
        // Use a wider detection area for touch devices
        if (isTouch || ('ontouchstart' in window)) {
            return FILTER_EDGE_DETECTION_WIDTH * 1.5; // 50% wider for touch devices
        }
        return FILTER_EDGE_DETECTION_WIDTH;
    }

    // Function to check if mouse is over a filter edge
    function isOverFilterEdge(clientX, clientY, canvas) {
        if (!canvas) canvas = el("spectrum");

        // Convert client coordinates to canvas coordinates
        const { x, y } = getCanvasCoordinates(clientX, clientY, canvas);

        const { width, height } = canvas;
        const drawHeight = height - 15;

        // Calculate filter edge positions directly
        const nbins = 1024; // Typical value for spectrum
        const calculated_span = nbins * 46.875;
        const hz_per_pixel = width / calculated_span;
        const half_width = width / 2;

        // Get current filter values
        const mode = el("MODE").value;

        // Skip filter edge detection for FTx modes
        if (mode === "FT8" || mode === "FT4") {
            return null;
        }

        const bw = parseFloat(el("BW").value);
        const low = parseFloat(el("LOW").value);
        const high = parseFloat(el("HIGH").value);

        let filterLeftX, filterRightX, visualLeftEdgeX, visualRightEdgeX;

        if (mode === "LSB" || mode === "CWR") {
            filterLeftX = half_width - hz_per_pixel * high;
            filterRightX = half_width - hz_per_pixel * low;
        } else if (mode === "AM") {
            const blockWidth = bw * hz_per_pixel * 2;
            filterLeftX = half_width - blockWidth / 2;
            filterRightX = half_width + blockWidth / 2;
        } else {
            filterLeftX = half_width + hz_per_pixel * low;
            filterRightX = half_width + hz_per_pixel * high;
        }

        // Calculate the visual edge positions (where the edges are actually drawn)
        visualLeftEdgeX = filterLeftX;
        visualRightEdgeX = filterRightX - 6; // Right edge is drawn 6 pixels to the left

        // Store these calculated positions for reference
        window.filterLeftEdgeX = filterLeftX;
        window.filterRightEdgeX = filterRightX;
        window.visualLeftEdgeX = visualLeftEdgeX;
        window.visualRightEdgeX = visualRightEdgeX;

        // Use the appropriate detection width based on device type
        const edgeWidth = getEdgeDetectionWidth();

        // Only detect if within the vertical area of the filter
        if (y >= 0 && y < drawHeight) {
            // Check left edge
            if (Math.abs(x - visualLeftEdgeX) < edgeWidth) {
                console.log(`Left edge detected at canvas x: ${x}, visualLeftEdgeX: ${visualLeftEdgeX}`);
                return 'left';
            }
            // Check right edge using the visual edge position
            if (Math.abs(x - visualRightEdgeX) < edgeWidth) {
                console.log(`Right edge detected at canvas x: ${x}, visualRightEdgeX: ${visualRightEdgeX}`);
                return 'right';
            }
        }

        return null;
    }

    // Handle filter edge dragging with proper scaling support
    function handleFilterDrag(event, isTouch = false) {
        if (!isFilterDragging) return;

        const currentX = isTouch ? event.touches[0].clientX : event.clientX;
        const deltaX = currentX - lastX;
        lastX = currentX;

        if (deltaX === 0) return;

        const canvas = el("spectrum");
        const rect = canvas.getBoundingClientRect();

        // Calculate the scaling ratio between canvas and display
        const scaleX = canvas.width / rect.width;

        // Adjust delta based on scaling ratio
        const adjustedDelta = deltaX * scaleX;

        const { width } = canvas;
        const nbins = 1024; // Typical value for spectrum
        const calculated_span = nbins * 46.875;
        const hz_per_pixel = width / calculated_span;

        // Get current filter values
        const mode = el("MODE").value;
        const bw = parseFloat(el("BW").value);
        let low = parseFloat(el("LOW").value);
        let high = parseFloat(el("HIGH").value);

        // Calculate Hz change based on pixel movement
        // Apply a multiplier to make dragging more responsive
        const multiplier = 1.5;
        const hzChange = Math.round((adjustedDelta / hz_per_pixel) * multiplier);

        console.log(`Dragging ${filterDragEdge} edge in ${mode} mode, deltaX: ${deltaX}, adjustedDelta: ${adjustedDelta}, scaleX: ${scaleX}, hzChange: ${hzChange}`);
        console.log(`Current filter values - low: ${low}, high: ${high}`);
        if (mode === "LSB" || mode === "CWR") {
            if (filterDragEdge === 'left') {
                // Left edge in LSB/CWR controls the high cut
                high -= hzChange;
                // Ensure high is at least 50 Hz greater than low
                high = Math.max(high, low + 50);
                // Limit high to reasonable values
                high = Math.min(Math.max(high, 300), 5000);
                websocket_send(`HIGH=${high}`);
                console.log(`Updated high to ${high}`);
            } else { // right edge
                // Right edge in LSB/CWR controls the low cut
                low -= hzChange;
                // Ensure low is at least 50 Hz less than high
                low = Math.min(low, high - 50);
                // Limit low to reasonable values
                low = Math.min(Math.max(low, 50), 4800);
                websocket_send(`LOW=${low}`);
                console.log(`Updated low to ${low}`);
            }
        } else if (mode === "AM") {
            // For AM, both edges move symmetrically to adjust bandwidth
            if (filterDragEdge === 'left' || filterDragEdge === 'right') {
                let newBw = bw + (hzChange / (filterDragEdge === 'left' ? -1 : 1));
                // Limit bandwidth to reasonable values
                newBw = Math.min(Math.max(newBw, 1000), 6000);
                websocket_send(`BW=${newBw}`);
                console.log(`Updated BW to ${newBw}`);
            }
        } else { // USB, CW, etc.
            if (filterDragEdge === 'left') {
                // Left edge in USB controls the low cut
                low += hzChange;
                // Ensure low is at least 50 Hz less than high
                low = Math.min(low, high - 50);
                // Limit low to reasonable values
                low = Math.min(Math.max(low, 50), 4800);
                websocket_send(`LOW=${low}`);
                console.log(`Updated low to ${low}`);
            } else { // right edge
                // Right edge in USB controls the high cut
                high += hzChange;
                // Ensure high is at least 50 Hz greater than low
                high = Math.max(high, low + 50);
                // Limit high to reasonable values
                high = Math.min(Math.max(high, 300), 5000);
                websocket_send(`HIGH=${high}`);
                console.log(`Updated high to ${high}`);
            }
        }
    }
    let accumulatedPixels = 0; // Accumulator for pixel movement
    const pixelsPerStep = 100; // Pixels required to trigger one step (adjustable)
    const maxMultiplier = 5; // Maximum step size multiplier
    const minSpeed = 100; // Pixels/sec for 1x multiplier (adjustable)
    const maxSpeed = 1000; // Pixels/sec for 5x multiplier (adjustable)
    const debounceInterval = 100; // Minimum time (ms) between frequency updates
    const residualThreshold = pixelsPerStep * 0.3; // Ignore residuals < 30% of pixelsPerStep on release

    function handleWaterfallDrag(event, isTouch = false) {
        if (isFilterDragging) {
            handleFilterDrag(event, isTouch);
            return;
        }

        if (!isDragging) return;

        // Get clientX from mouse or touch event
        const currentX = isTouch ? event.touches[0].clientX : event.clientX;
        const deltaX = currentX - lastX; // Positive if moving right, negative if left
        const currentTime = performance.now(); // Current time in milliseconds
        const deltaTime = (currentTime - lastTime) / 1000; // Time difference in seconds
        const stepSize = getStepSize(); // e.g., 10, 100, 1000 Hz

        // Calculate drag speed (pixels per second)
        const speed = deltaTime > 0 ? Math.abs(deltaX / deltaTime) : 0; // Avoid division by zero

        // Compute multiplier based on speed (linear interpolation between minSpeed and maxSpeed)
        let multiplier = 1;
        if (speed >= minSpeed) {
            multiplier = 1 + (speed - minSpeed) * (maxMultiplier - 1) / (maxSpeed - minSpeed);
            multiplier = Math.min(maxMultiplier, Math.max(1, multiplier)); // Clamp between 1 and 5
        }

        // Accumulate raw pixel movement
        accumulatedPixels += deltaX;

        // Calculate number of steps based on accumulated pixels, adjusted by multiplier
        const effectivePixelsPerStep = pixelsPerStep / multiplier; // Smaller threshold for faster drags
        const steps = Math.floor(accumulatedPixels / effectivePixelsPerStep); // Integer steps

        // Apply frequency update only if steps exist and debounce interval has passed
        if (steps !== 0 && (currentTime - lastUpdateTime) >= debounceInterval) {
            // Update frequency: dragging right (deltaX > 0) decreases freq
            let freq = parseInt(el('FREQ').value);
            freq -= steps * stepSize; // Apply steps * stepSize (e.g., -1000 Hz for 1 kHz step)
            freq = Math.round(freq / stepSize) * stepSize; // Snap to step grid

            // Apply update if frequency changed
            if (freq !== parseInt(el('FREQ').value)) {
                update_freq(freq);
                console.log(`Waterfall drag freq: ${freq} (deltaX: ${deltaX}, speed: ${speed.toFixed(2)} px/s, multiplier: ${multiplier.toFixed(2)}, steps: ${steps})`);
            }

            // Reduce accumulated pixels by the amount used
            accumulatedPixels -= steps * effectivePixelsPerStep;
            lastUpdateTime = currentTime; // Update last update time
        }

        lastX = currentX; // Update last position
        lastTime = currentTime; // Update last time
        if (!isTouch) event.preventDefault(); // Prevent text selection for mouse
    }

    function startWaterfallDrag(event, isTouch = false) {
        if (isTouch && event.touches.length !== 1) return;

        // Check if we're clicking on a filter edge in the spectrum display
        const canvas = isTouch ? event.touches[0].target : event.target;
        if (canvas.id === "spectrum") {
            const rect = canvas.getBoundingClientRect();
            const x = (isTouch ? event.touches[0].clientX : event.clientX) - rect.left;
            const y = (isTouch ? event.touches[0].clientY : event.clientY) - rect.top;

            // Force recalculation of filter edges
            const spectrumCanvas = el("spectrum");
            const { width, height } = spectrumCanvas;
            const drawHeight = height - 15;
            const nbins = 1024; // Typical value for spectrum
            const calculated_span = nbins * 46.875;
            const hz_per_pixel = width / calculated_span;
            const half_width = width / 2;

            // Get current filter values
            const mode = el("MODE").value;
            const bw = parseFloat(el("BW").value);
            const low = parseFloat(el("LOW").value);
            const high = parseFloat(el("HIGH").value);

            let filterLeftX, filterRightX;

            if (mode === "LSB" || mode === "CWR") {
                filterLeftX = half_width - hz_per_pixel * high;
                filterRightX = half_width - hz_per_pixel * low;
            } else if (mode === "AM") {
                const blockWidth = bw * hz_per_pixel * 2;
                filterLeftX = half_width - blockWidth / 2;
                filterRightX = half_width + blockWidth / 2;
            } else {
                filterLeftX = half_width + hz_per_pixel * low;
                filterRightX = half_width + hz_per_pixel * high;
            }

            // Use a wider detection area (20 pixels) for clicking
            const edgeWidth = getEdgeDetectionWidth(false);
            let edge = null;

            // For LSB/CWR, the left edge is high cut and right edge is low cut
            // For USB/CW/others, the left edge is low cut and right edge is high cut
            // For AM, both edges adjust bandwidth symmetrically

            // Check left edge first (closer to the left side of the canvas)
            if (Math.abs(x - filterLeftX) < edgeWidth && y < drawHeight) {
                edge = 'left';
            }
            // Then check right edge (closer to the right side of the canvas)
            else if (Math.abs(x - filterRightX) < edgeWidth && y < drawHeight) {
                edge = 'right';
            }

            console.log(`Clicked at x: ${x}, y: ${y}, filterLeftX: ${filterLeftX}, filterRightX: ${filterRightX}, edge detected: ${edge}`);

            if (edge) {
                isFilterDragging = true;
                filterDragEdge = edge;
                lastX = isTouch ? event.touches[0].clientX : event.clientX;
                canvas.style.cursor = 'ew-resize';
                console.log(`Started dragging ${edge} filter edge`);
                event.preventDefault();
                return;
            }
        }

        // If not dragging a filter edge, proceed with normal waterfall drag
        isDragging = true;
        lastX = isTouch ? event.touches[0].clientX : event.clientX;
        lastTime = performance.now(); // Initialize time
        lastUpdateTime = 0; // Reset last update time
        accumulatedPixels = 0; // Reset accumulator
        event.preventDefault();
    }

    function stopWaterfallDrag() {
        // Handle filter edge dragging stop
        if (isFilterDragging) {
            console.log('Stopped filter edge dragging');
            isFilterDragging = false;
            filterDragEdge = null;
            // Reset cursor
            el("spectrum").style.cursor = 'default';
            return;
        }

        if (isDragging) {
            setTimeout(() => {
                const stepSize = getStepSize();
                let freq = parseInt(el('FREQ').value);
                let effectiveSteps = 0;

                // Determine drag direction and apply steps based on threshold
                const threshold = pixelsPerStep * 0.5; // Require 50% of pixelsPerStep to trigger a step
                if (accumulatedPixels > threshold) {
                    // Right drag (positive pixels): decrease frequency
                    effectiveSteps = Math.floor(accumulatedPixels / pixelsPerStep); // Round down
                } else if (accumulatedPixels < -threshold) {
                    // Left drag (negative pixels): increase frequency
                    effectiveSteps = Math.ceil(accumulatedPixels / pixelsPerStep); // Round up
                }

                if (effectiveSteps !== 0) {
                    freq -= effectiveSteps * stepSize; // Apply steps (negative steps increase freq)
                    freq = Math.round(freq / stepSize) * stepSize; // Snap to step grid
                    if (freq !== parseInt(el('FREQ').value)) {
                        update_freq(freq);
                        console.log(`Waterfall drag end freq: ${freq} (final steps: ${effectiveSteps}, accumulatedPixels: ${accumulatedPixels})`);
                    }
                }
                accumulatedPixels = 0; // Reset after processing
            }, 50); // Small delay for touch events
        }
        isDragging = false;
    }

    // Attach event listeners
    const waterfallCanvas = el("waterfall");
    const spectrumCanvas = el("spectrum");

    // Mouse events for waterfall
    waterfallCanvas.addEventListener("mousedown", (e) => startWaterfallDrag(e, false));
    waterfallCanvas.addEventListener("mousemove", (e) => handleWaterfallDrag(e, false));
    waterfallCanvas.addEventListener("mouseup", stopWaterfallDrag);
    waterfallCanvas.addEventListener("mouseleave", stopWaterfallDrag);

    // Function to handle cursor changes when hovering over filter edges
    function handleFilterEdgeHover(event) {
        const canvas = el("spectrum");

        // Use our new edge detection function that handles scaling properly
        const edge = isOverFilterEdge(event.clientX, event.clientY, canvas);

        if (edge) {
            canvas.style.cursor = 'ew-resize';
            return true;
        } else {
            canvas.style.cursor = 'default';
            return false;
        }
    }

    // Mouse events for spectrum (filter dragging)
    spectrumCanvas.addEventListener("mousedown", (e) => {
        // Get canvas coordinates directly
        const rect = spectrumCanvas.getBoundingClientRect();
        const scaleX = spectrumCanvas.width / rect.width;
        const scaleY = spectrumCanvas.height / rect.height;

        // Convert client coordinates to canvas coordinates
        const canvasX = (e.clientX - rect.left) * scaleX;
        const canvasY = (e.clientY - rect.top) * scaleY;

        // Get the current visual edge positions
        const visualLeftEdgeX = window.visualLeftEdgeX;
        const visualRightEdgeX = window.visualRightEdgeX;

        // Use a very wide detection area for better usability
        const edgeWidth = getEdgeDetectionWidth(false);

        let edge = null;

        // Check if we're clicking on a filter edge
        if (Math.abs(canvasX - visualLeftEdgeX) < edgeWidth) {
            edge = 'left';
            console.log(`Left edge clicked at canvas x: ${canvasX}, visualLeftEdgeX: ${visualLeftEdgeX}`);
        } else if (Math.abs(canvasX - visualRightEdgeX) < edgeWidth) {
            edge = 'right';
            console.log(`Right edge clicked at canvas x: ${canvasX}, visualRightEdgeX: ${visualRightEdgeX}`);
        }

        if (edge) {
            // If over a filter edge, start filter dragging
            isFilterDragging = true;
            filterDragEdge = edge;
            lastX = e.clientX; // Keep original clientX for dragging
            spectrumCanvas.style.cursor = 'ew-resize';
            console.log(`Started dragging ${edge} filter edge directly`);
            e.preventDefault();
            e.stopPropagation(); // Prevent waterfall drag from activating
        } else {
            // Otherwise, proceed with normal waterfall drag
            startWaterfallDrag(e, false);
        }
    });

    spectrumCanvas.addEventListener("mousemove", (e) => {
        // Check if we're already dragging a filter edge
        if (isFilterDragging) {
            handleFilterDrag(e, false);
            e.preventDefault();
            e.stopPropagation(); // Prevent waterfall drag from activating
            return;
        }

        // Get canvas coordinates directly
        const rect = spectrumCanvas.getBoundingClientRect();
        const scaleX = spectrumCanvas.width / rect.width;
        const scaleY = spectrumCanvas.height / rect.height;

        // Convert client coordinates to canvas coordinates
        const canvasX = (e.clientX - rect.left) * scaleX;
        const canvasY = (e.clientY - rect.top) * scaleY;

        // Get the current visual edge positions
        const visualLeftEdgeX = window.visualLeftEdgeX;
        const visualRightEdgeX = window.visualRightEdgeX;

        // Use a very wide detection area for better usability
        const edgeWidth = getEdgeDetectionWidth(false);

        // Check if we're hovering over a filter edge
        if (Math.abs(canvasX - visualLeftEdgeX) < edgeWidth ||
            Math.abs(canvasX - visualRightEdgeX) < edgeWidth) {
            // Over a filter edge
            spectrumCanvas.style.cursor = 'ew-resize';
            // Don't handle waterfall drag
        } else {
            // Not over a filter edge
            spectrumCanvas.style.cursor = 'default';
            // Handle waterfall drag if active
            if (isDragging) {
                handleWaterfallDrag(e, false);
            }
        }
    });

    spectrumCanvas.addEventListener("mouseup", stopWaterfallDrag);
    spectrumCanvas.addEventListener("mouseleave", stopWaterfallDrag);

    // Global mouse up to ensure drag stops even if cursor leaves canvas
    document.addEventListener("mouseup", stopWaterfallDrag);

    // Touch events for waterfall
    waterfallCanvas.addEventListener("touchstart", (e) => startWaterfallDrag(e, true));
    waterfallCanvas.addEventListener("touchmove", (e) => handleWaterfallDrag(e, true));
    waterfallCanvas.addEventListener("touchend", stopWaterfallDrag);
    waterfallCanvas.addEventListener("touchcancel", stopWaterfallDrag);

    // Touch events for spectrum (filter dragging)
    spectrumCanvas.addEventListener("touchstart", (e) => {
        // Get canvas coordinates directly
        if (e.touches.length !== 1) return;

        const rect = spectrumCanvas.getBoundingClientRect();
        const scaleX = spectrumCanvas.width / rect.width;
        const scaleY = spectrumCanvas.height / rect.height;

        // Convert client coordinates to canvas coordinates
        const canvasX = (e.touches[0].clientX - rect.left) * scaleX;
        const canvasY = (e.touches[0].clientY - rect.top) * scaleY;

        // Get the current visual edge positions
        const visualLeftEdgeX = window.visualLeftEdgeX;
        const visualRightEdgeX = window.visualRightEdgeX;

        // Use a wider detection area for touch devices
        const edgeWidth = getEdgeDetectionWidth(true);

        let edge = null;

        // Check if we're touching a filter edge
        if (Math.abs(canvasX - visualLeftEdgeX) < edgeWidth) {
            edge = 'left';
            console.log(`Left edge touched at canvas x: ${canvasX}, visualLeftEdgeX: ${visualLeftEdgeX}`);
        } else if (Math.abs(canvasX - visualRightEdgeX) < edgeWidth) {
            edge = 'right';
            console.log(`Right edge touched at canvas x: ${canvasX}, visualRightEdgeX: ${visualRightEdgeX}`);
        }

        if (edge) {
            // If over a filter edge, start filter dragging
            isFilterDragging = true;
            filterDragEdge = edge;
            lastX = e.touches[0].clientX; // Keep original clientX for dragging
            console.log(`Started dragging ${edge} filter edge on touch device`);
            e.preventDefault();
            e.stopPropagation(); // Prevent waterfall drag from activating
        } else {
            // Otherwise, proceed with normal waterfall drag
            startWaterfallDrag(e, true);
        }
    });

    spectrumCanvas.addEventListener("touchmove", (e) => {
        // Check if we're already dragging a filter edge
        if (isFilterDragging) {
            handleFilterDrag(e, true);
            e.preventDefault();
            e.stopPropagation(); // Prevent waterfall drag from activating
            return;
        }

        // Otherwise, proceed with normal waterfall drag
        handleWaterfallDrag(e, true);
    });

    spectrumCanvas.addEventListener("touchend", stopWaterfallDrag);
    spectrumCanvas.addEventListener("touchcancel", stopWaterfallDrag);
    // created by OZ7BX

    function calcGradientFarhan(v) {
        if (v > 100) {
            v = 100;
        }
        let clr = {};
        if (v < 20) {
            clr.r = 0;
            clr.g = 0;
            clr.b = v * 12;
        }
        else if (v < 40) {
            clr.r = 0;
            clr.g = (v - 20) * 12;
            clr.b = 255;
        }
        else if (v < 60) {
            clr.r = 0;
            clr.g = 255;
            clr.b = (60 - v) * 12;
        }
        else if (v < 80) {
            clr.r = (v - 60) * 12;
            clr.g = 255;
            clr.b = 0;
        }
        else {
            clr.r = 255;
            clr.g = (100 - v) * 12;
            clr.b = 0;
        }
        return clr;
    }

    function calcGradient(v) {
        if (v > 100) {
            v = 100;
        }
        let clr = {};
        if (v < 20) {
            const t = v / 20.0;
            clr.r = 0;
            clr.g = 0;
            clr.b = Math.round(t * 255);
        }
        else if (v < 40) {
            const t = (v - 20) / 20.0;
            clr.r = 0;
            clr.g = Math.round(t * 255);
            clr.b = 255;
        }
        else if (v < 60) {
            const t = (v - 40) / 20.0;
            clr.r = 0;
            clr.g = 255;
            clr.b = Math.round((1.0 - t) * 255);
        }
        else if (v < 80) {
            const t = (v - 60) / 20.0;
            clr.r = Math.round(t * 255);
            clr.g = 255;
            clr.b = 0;
        }
        else {
            const t = (v - 80) / 20.0;
            clr.r = 255;
            clr.g = Math.round((1.0 - t) * 255);
            clr.b = 0;
        }
        return clr;
    }

    var nbins = 0;

    // Cache DOM elements (assumed to be stable) outside the function
    const spectrumEl = el("spectrum");
    const modeEl = el("MODE");
    const bwEl = el("BW");
    const lowEl = el("LOW");
    const highEl = el("HIGH");
    const statusEl = el("STATUS");
    const freqEl = el("FREQ");
    const pitchEl = el("PITCH");
    const txPitchEl = el("TX_PITCH");

    // Precompute gradient if calcGradient is deterministic
    const gradientCache = new Map(); // Cache gradient colors for values of v
    let cachedGradient = null; // Cache the linear gradient


    // Global declarations
    let activeSpots = new Map(); // Map<callsign, { spot, last_seen }>
    const SPOT_TIMEOUT = 15000; // 15 seconds

    function spectrum_update(update) {
        const { width, height } = spectrumEl;
        const ctx = spectrumEl.getContext("2d");
        const nbins = update.length - 3;
        const scale = width / nbins;
        const drawHeight = height - 15; // Keep original height allocation
        const calculated_span = nbins * 46.875;
        const hz_per_pixel = width / calculated_span;
        const half_width = width / 2;

        // Clear canvas
        ctx.fillStyle = "#000";
        ctx.fillRect(0, 0, width, height);

        // Create or reuse gradient
        if (!cachedGradient) {
            cachedGradient = ctx.createLinearGradient(0, 0, 0, drawHeight);
            for (let v = 0; v <= 100; v++) {
                let clr = gradientCache.get(100 - v);
                if (!clr) {
                    clr = calcGradient(100 - v);
                    gradientCache.set(100 - v, clr);
                }
                cachedGradient.addColorStop(v / 100, `rgb(${clr.r},${clr.g},${clr.b})`);
            }
        }

        // Cache DOM values
        const mode = modeEl.value;
        const bw = parseFloat(bwEl.value);
        const low = parseFloat(lowEl.value);
        const high = parseFloat(highEl.value);
        const status = statusEl.value;

        // Draw filter block
        ctx.fillStyle = "#444";
        let filterLeftX, filterRightX;

        if (mode === "LSB" || mode === "CWR") {
            filterLeftX = half_width - hz_per_pixel * high;
            filterRightX = half_width - hz_per_pixel * low;
            ctx.fillRect(filterLeftX, 0, (high - low) * hz_per_pixel, drawHeight);
        } else if (mode === "AM") {
            const blockWidth = bw * hz_per_pixel * 2;
            filterLeftX = half_width - blockWidth / 2;
            filterRightX = half_width + blockWidth / 2;
            ctx.fillRect(filterLeftX, 0, blockWidth, drawHeight);
        } else {
            filterLeftX = half_width + hz_per_pixel * low;
            filterRightX = half_width + hz_per_pixel * high;
            ctx.fillRect(filterLeftX, 0, (high - low) * hz_per_pixel, drawHeight);
        }

        // Skip filter visualization for FTx modes
        if (mode !== "FT8" && mode !== "FT4") {
            // Calculate the visual edge positions (where the edges are actually drawn)
            const visualLeftEdgeX = filterLeftX;
            const visualRightEdgeX = filterRightX - 6; // Right edge is drawn 6 pixels to the left

            // Store both the filter positions and visual edge positions for detection
            window.filterLeftEdgeX = filterLeftX;
            window.filterRightEdgeX = filterRightX;
            window.visualLeftEdgeX = visualLeftEdgeX;
            window.visualRightEdgeX = visualRightEdgeX;

            // Draw filter edges with a more prominent color to indicate they're draggable
            ctx.fillStyle = "#666";
            ctx.fillRect(visualLeftEdgeX, 0, 6, drawHeight); // Left edge
            ctx.fillRect(visualRightEdgeX, 0, 6, drawHeight); // Right edge
        }

        // Add a highlight effect at the top of the edges
        //ctx.fillStyle = "#aaa";
        //ctx.fillRect(visualLeftEdgeX, 0, 6, 5); // Left edge highlight
        //ctx.fillRect(visualRightEdgeX, 0, 6, 5); // Right edge highlight

        // Debug visualization removed for production

        // Debug logging removed for production

        // Draw grid
        ctx.beginPath();
        for (let x = 0; x <= 10; x++) {
            const px = width * x / 10;
            ctx.moveTo(px, 0);
            ctx.lineTo(px, drawHeight);
        }
        for (let y = 0; y <= 8; y++) {
            const py = drawHeight * y / 8;
            ctx.moveTo(0, py);
            ctx.lineTo(width, py);
        }
        ctx.strokeStyle = "#333";
        ctx.stroke();

        // Plot spectrum
        if (update.startsWith("TX")) {
            ctx.beginPath();
            const centerY = drawHeight * 4.5/8; // Exactly between the middle grid lines
            // Get the first sample value normalized to -1 to 1 range
            const firstSample = ((update.charCodeAt(3) - 32) / 50) - 1;
            ctx.moveTo(width, centerY + (firstSample * (drawHeight/8) * 2)); // Scale by 2 grid cells

            for (let x = 0; x < nbins; x++) {
                const px = (nbins - x - 1) * scale;
                // Normalize the sample value to -1 to 1 range and center it
                const sampleValue = ((update.charCodeAt(x + 3) - 32) / 50) - 1;
                const py = centerY + (sampleValue * (drawHeight/8) * 2); // Scale by 2 grid cells to match moveTo
                ctx.lineTo(px, py);
            }
            ctx.strokeStyle = "#ffff00";
            ctx.stroke();
        } else {
            const binWidth = Math.max(1, scale);
            for (let x = 0; x < nbins; x++) {
                const px = (nbins - x - 1) * scale;

                // Adjust the spectrum level calculation for FT8 mode
                let ph;
                if (mode === "FT8" || mode === "FT4") {
                    // Use a more appropriate scaling for FT8 mode
                    ph = -((update.charCodeAt(x + 3) - 32) * drawHeight) / 100;
                } else {
                    // Original calculation for other modes
                    ph = -((update.charCodeAt(x + 3) - 32) * drawHeight * 2) / 100;
                }

                ctx.fillStyle = cachedGradient;
                ctx.fillRect(px, drawHeight - 1, binWidth, ph);
            }
        }

        // Draw status
        ctx.fillStyle = "orange";
        ctx.font = "14px Sans";
        ctx.fillText(status, 5, 14);

        // Draw spots
        const freq = parseInt(freqEl.value) / 1000; // Current frequency in kHz
        const currentTime = Date.now();
        const spots_with_x = [];

        // Update active spots: process new spots and remove expired ones
        const newSpots = new Map();

        // Process incoming spots, keeping newest per callsign within frequency range
        for (const spot of spots) {
            if (Math.abs(spot.frequency - freq) < 25) {
                const existing = newSpots.get(spot.callsign);
                if (!existing || (spot.timestamp || currentTime) > (existing.spot.timestamp || 0)) {
                    newSpots.set(spot.callsign, {
                        spot,
                        last_seen: currentTime
                    });
                }
            }
        }

        // Copy still-valid spots from activeSpots, excluding expired ones
        for (const [callsign, entry] of activeSpots) {
            if (currentTime - entry.last_seen <= SPOT_TIMEOUT && Math.abs(entry.spot.frequency - freq) < 25) {
                newSpots.set(callsign, entry);
            }
        }

        // Update activeSpots with filtered spots
        activeSpots = newSpots;

        // Collect spots for drawing
        for (const [callsign, { spot }] of activeSpots) {
            const spot_freq = spot.frequency * 1000;
            const relative_freq = spot_freq - freq * 1000;
            const spot_x = half_width + relative_freq * hz_per_pixel;
            spots_with_x.push({ x: spot_x, callsign, timestamp: spot.timestamp || currentTime });
        }

        // Sort spots by x-coordinate for overlap handling
        spots_with_x.sort((a, b) => a.x - b.x);

        // Draw spot lines and labels (only if label fits)
        ctx.strokeStyle = "yellow";
        ctx.fillStyle = "white";
        ctx.font = "12px Sans";
        let last_x = -100;

        for (const spot of spots_with_x) {
            const label_x = spot.x - 10;
            const min_gap = ctx.measureText(spot.callsign).width + 5;
            if (Math.abs(label_x - last_x) > min_gap) {
                // Draw line and label only if label fits
                ctx.beginPath();
                ctx.moveTo(spot.x, 0);
                ctx.lineTo(spot.x, drawHeight);
                ctx.stroke();
                ctx.fillText(spot.callsign, label_x, drawHeight + 12);
                last_x = label_x;
            }
        }

        // Draw RX/TX lines
        const rx_pitch = parseFloat(pitchEl.value);
        const tx_pitch = mode === "AM" ? 0 : parseFloat(txPitchEl.value);
        const rit = el("RIT").value;
        const rit_delta = parseInt(el("RIT_DELTA").value) || 0;

        ctx.beginPath();
        ctx.strokeStyle = "cyan";
        ctx.fillStyle = "white";
        ctx.font = "12px Sans";
        let rx_x;

        if (mode === "USB" || mode === "LSB" || mode === "DIGI" || mode === "AM") {
            rx_x = half_width;
        } else if (mode === "CWR") {
            rx_x = half_width - rx_pitch * hz_per_pixel;
        } else {
            rx_x = half_width + rx_pitch * hz_per_pixel;
        }

        // Check for overlap with spot labels
        const rx_label_x = rx_x - 10;
        let rx_label_overlaps = false;
        const rx_label_width = ctx.measureText("RX").width + 5;

        for (const spot of spots_with_x) {
            const spot_label_x = spot.x - 10;
            const spot_label_width = ctx.measureText(spot.callsign).width + 5;
            const min_gap = Math.max(rx_label_width, spot_label_width);
            if (Math.abs(rx_label_x - spot_label_x) < min_gap) {
                rx_label_overlaps = true;
                break;
            }
        }

        // Draw RX line and conditionally draw RX label
        ctx.moveTo(rx_x, 0);
        ctx.lineTo(rx_x, drawHeight);
        if (!rx_label_overlaps) {
            ctx.fillText("RX", rx_label_x, drawHeight + 12);
        }
        ctx.stroke();

        if (mode === "FT8" || mode === "FT4") {
            ctx.beginPath();
            ctx.strokeStyle = "red";
            ctx.fillStyle = "red";
            const tx_x = half_width + tx_pitch * hz_per_pixel;
            ctx.moveTo(tx_x, 0);
            ctx.lineTo(tx_x, drawHeight);
            ctx.fillText("TX", tx_x - 10, drawHeight + 12);
            ctx.stroke();
        }

        // Draw TX frequency indicator when RIT is enabled.
        // Similar to the implementation we have in sbitx_gtk.c for the local visualizations
        if (rit === "ON" && !in_tx) {
            ctx.beginPath();
            ctx.strokeStyle = "red";
            ctx.fillStyle = "red";

            // Calculate TX frequency position
            // TX freq = RX freq - RIT delta (same calculation as in GTK)
            const freq_diff = -rit_delta; // Negative because we subtract RIT delta from RX freq
            const offset_pixels = freq_diff * hz_per_pixel;
            const tx_needle_x = half_width + offset_pixels;

            // Check if TX indicator is within visible range
            let is_at_edge = false;
            let arrow_direction = 0;
            let display_x = tx_needle_x;

            if (tx_needle_x < 0) {
                display_x = 0;
                is_at_edge = true;
                arrow_direction = -1;
            }
            if (tx_needle_x >= width) {
                display_x = width - 1;
                is_at_edge = true;
                arrow_direction = 1;
            }

            // Draw the vertical line
            ctx.moveTo(display_x, 0);
            ctx.lineTo(display_x, drawHeight);
            ctx.stroke();

            // Draw arrow if TX frequency is outside visible range
            if (is_at_edge) {
                const center_y = drawHeight / 2;
                const arrow_size = 10;

                ctx.beginPath();
                ctx.moveTo(display_x, center_y);

                if (arrow_direction < 0) {
                    // Arrow pointing right (TX is to the left of visible area)
                    ctx.lineTo(display_x + arrow_size, center_y - arrow_size/2);
                    ctx.lineTo(display_x + arrow_size, center_y + arrow_size/2);
                } else {
                    // Arrow pointing left (TX is to the right of visible area)
                    ctx.lineTo(display_x - arrow_size, center_y - arrow_size/2);
                    ctx.lineTo(display_x - arrow_size, center_y + arrow_size/2);
                }

                ctx.closePath();
                ctx.fill();
            }

            // Add TX label if there's room
            const tx_label_x = display_x - 10;
            let tx_label_overlaps = false;
            const tx_label_width = ctx.measureText("TX").width + 5;

            // Check for overlap with spot labels and RX label
            for (const spot of spots_with_x) {
                const spot_label_x = spot.x - 10;
                const spot_label_width = ctx.measureText(spot.callsign).width + 5;
                const min_gap = Math.max(tx_label_width, spot_label_width);
                if (Math.abs(tx_label_x - spot_label_x) < min_gap) {
                    tx_label_overlaps = true;
                    break;
                }
            }

            // Also check overlap with RX label
            if (Math.abs(tx_label_x - rx_x + 10) < tx_label_width) {
                tx_label_overlaps = true;
            }

            if (!tx_label_overlaps) {
                ctx.fillText("TX", tx_label_x, drawHeight + 12);
            }
        }
    }
    // Cache DOM elements (assumed to be stable) outside the function
    const waterfallEl = el("waterfall");

    function waterfall_update(update) {
        const { width, height } = waterfallEl;
        if (width === 0 || height === 0) return;

        const ctx = waterfallEl.getContext("2d", { willReadFrequently: true });
        const nbins = update.length - 3;
        const scale = nbins / width;
        const calculated_span = nbins * 46.875;
        const hz_per_pixel = width / calculated_span;
        const half_width = width / 2; // Precompute for reuse

        // Get mode and pitch values
        const mode = modeEl.value;
        const rx_pitch = parseFloat(pitchEl.value);
        const tx_pitch = mode === "FT8" || mode === "FT4" ? parseFloat(txPitchEl.value) : 0;

        // Calculate repeat and spot positions
        const repeat = mode === "FT8" || mode === "FT4" ? 1 : mode === "CW" || mode === "CWR" ? 2 : 2;

        // Simplify rx_spot calculation
        let rx_spot;
        if (mode === "USB" || mode === "LSB" || mode === "DIGI" || mode === "AM") {
            rx_spot = Math.round(half_width);
        } else if (mode === "CWR") {
            rx_spot = Math.round(half_width - rx_pitch * hz_per_pixel);
        } else {
            rx_spot = Math.round(half_width + rx_pitch * hz_per_pixel);
        }

        const tx_spot = mode === "FT8" || mode === "FT4" ? Math.round(half_width + tx_pitch * hz_per_pixel) : -1;

        // Shift existing image down
        const img = ctx.getImageData(0, 0, width, height);
        ctx.putImageData(img, 0, repeat);

        // Create and fill strip data
        const strip = ctx.createImageData(width, 1);
        const data = strip.data; // Uint8ClampedArray
        let i = 0;

        for (let x = 0; x < width; x++) {
            const bin = Math.floor((width - x) * scale);
            let v = (update.charCodeAt(bin + 3) - 32) * 2;
            v = Math.min(v, 100);

            // Use cached gradient if available
            let clr = gradientCache.get(v);
            if (!clr) {
                clr = calcGradient(v);
                gradientCache.set(v, clr);
            }

            // Set pixel data efficiently
            data[i++] = x === tx_spot ? 255 : clr.r;
            data[i++] = x === rx_spot ? 255 : clr.g;
            data[i++] = x === rx_spot ? 255 : clr.b;
            data[i++] = 255; // Alpha
        }

        // Draw the strip once (avoid looping if repeat is small)
        if (repeat === 1) {
            ctx.putImageData(strip, 0, 0);
        } else {
            for (let i = 0; i < repeat; i++) {
                ctx.putImageData(strip, 0, i);
            }
        }
    }

    /* on screen keyboard panel */

    var text_focus = null;

    function sbitx_text_focus(event) {
        text_focus = event.currentTarget;
    }

    function sbitx_onscreen_key(event) {
        event.stopImmediatePropagation();
        var key = event.currentTarget.innerHTML;

        if (text_focus == null)
            return;

        //translate keys
        if (key == 'SPACE')
            key = ' ';
        else if (key == 'CMD')
            key = '\\';
        else if (key == 'Enter')
            key = '\n';

        //sent key strokes to be transmitted
        //even if the focus is not on datawindow
        //as long as we have the CW_ui opened

        if (text_focus.id == "data_window" ||
            (el("CW_ui").style.display == "block" && text_focus == null)) {
            if (key == '\u21E4')
                websocket_send("key " + String.fromCharCode(8));
            else if (key == '\u23D8')
                $("#keybd").hide();
            else if (key == '\u2716')
                websocket_send("key " + key);
            return;
        }

        var caret = text_focus.selectionStart;
        var string = text_focus.value;

        //backspace
        if (key == '\u21E4' || key == 'DEL') {
            text_focus.value = string.substring(0, caret - 1) + string.substring(caret);
            move_caret(text_focus, caret - 1);
        }//enter key when the focus is on text_in
        else if ((key == "\u8617" || key == '\n') && text_focus.id == "text_in") {
        if (text_focus.value.toUpperCase() === "CLEAR") {
          FT8_lists_clear();
         }
            websocket_send(text_focus.value);
            text_focus.value = "";
        }
        else if (key == '\u23D8') {
            text_focus.value = string.substring(0, caret) + ' ' + string.substring(caret);
            move_caret(text_focus, caret + 1);
        }
        else if (key == '[x]') {
            $("#keybd").hide();
        }
        else {
            if (key == '\u21A9')
                key = '\n';
            text_focus.value = string.substring(0, caret) + key + string.substring(caret);
            move_caret(text_focus, caret + 1);
        }
    }

    function show_keyboard() {
        $("#keybd").show();
    }
    /* Filter Panel */

    function receiver_panel_open() {
        log("intializing the receiver panel");
        //resize the waterfall and the spectrum, both need to be visible when tuning
        var waterfall = el("waterfall");
        var spectrum = el("spectrum");
        //	spectrum.height = 50;
        //	waterfall.height = 50;

    }

    function filter_set(event) {
        var id = parseInt(event.currentTarget.id);
        var center = parseInt(el("PITCH").value);
        var mode = el("MODE").value;
        var low = 300;
        var high = 3000;

        websocket_send("bandwidth " + id);
    }

    /* audio stuff (this needs to work with webrtc data packets rather than websockets */
    //setup the audio
    var rxAudioContext = null;
    var rxWorkletNode = null;
    var rxAudioInitialized = false;
    var micStream = null;
    var micContext = null;
    var prev_sample = 0;
    var intp_factor = 6; //we will interpolate from 8 khz to 48 khz
    var sound_mute = false;
    var f = null;
    // Set up variables for browser microphone - single global object to prevent duplication
    window.sbitxMic = window.sbitxMic || {
        enabled: false,
        initialized: false,
        stream: null,
        context: null,
        workletNode: null,        // AudioWorklet node (replaces processor)
        buffer: [],
        bufferSize: 512,          // Buffer size for audio processing
        bufferThreshold: 256,     // Send when buffer reaches this size
        sendIntervalMs: 50,       // Send interval in milliseconds
        sendInterval: null,       // Interval reference
        lastSendTime: 0,          // Timestamp of last audio send
        initCount: 0              // Track initialization attempts
    };

    function toggleBrowserMic() {
        // Toggle mic state using the global object
        window.sbitxMic.enabled = !window.sbitxMic.enabled;
        var micBtn = document.getElementById('browser_mic');

        if (window.sbitxMic.enabled) {
            micBtn.textContent = "Browser Mic\nON";
            //micBtn.style.backgroundColor = "yellow";
            console.log("Browser microphone enabled");

            // Initialize microphone if not already done
            if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
                // Only initialize once
                if (!window.sbitxMic.initialized) {
                    console.log("Initializing browser mic");
                    initBrowserMic();
                }

                // Set up the audio send interval only once
                if (!window.sbitxMic.sendInterval) {
                    setupAudioSendInterval();
                }
            } else {
                console.log("Browser microphone not supported");
            }
        } else {
            micBtn.textContent = "Browser Mic\nOFF";
            micBtn.style.backgroundColor = "";
            console.log("Browser microphone disabled");

            // Clear the audio buffer when mic is disabled
            window.sbitxMic.buffer = [];
        }
    }

    async function audio_start() {
        try {
            // Initialize the RX audio worklet if not already initialized
            if (!rxAudioInitialized) {
                // Create audio context
                rxAudioContext = new (window.AudioContext || window.webkitAudioContext)();

                // Load the audio worklet module
                try {
                    await rxAudioContext.audioWorklet.addModule('rxProcessor.js');
                    log("RX AudioWorklet module loaded successfully");

                    // Create the worklet node with processor options
                    rxWorkletNode = new AudioWorkletNode(
                        rxAudioContext,
                        'audio-playback-processor',
                        {
                            // Pass the correct sample rate information
                            processorOptions: {
                                inputSampleRate: 16000, // The sBitx system decimates from 96kHz to 16kHz
                                outputSampleRate: rxAudioContext.sampleRate,
                                debug: false // Set to true to enable buffer logging for debugging
                            }
                        }
                    );

                    // Connect the node to the audio output
                    rxWorkletNode.connect(rxAudioContext.destination);

                    // Handle messages from the processor
                    rxWorkletNode.port.onmessage = (event) => {
                        const { status, level } = event.data;

                        if (status === "buffer_low") {
                            // Buffer is running low, could log or handle this
                            // console.log("Audio buffer running low");
                        } else if (status === "buffer_full") {
                            // Buffer is full, could throttle sending data
                            // console.log("Audio buffer full");
                        } else if (status === "buffer_level") {
                            // Could use this to display a buffer level indicator
                            // console.log(`Buffer level: ${level * 100}%`);
                        }
                    };

                    rxAudioInitialized = true;
                    log("RX audio worklet initialized successfully");

                    // Request audio data from the server after initialization
                    if (session_id !== 'nullsession') {
                        websocket_send("audio");
                    }
                } catch (workletError) {
                    log("Failed to load RX AudioWorklet: " + workletError + ". Falling back to PCMPlayer.");
                    // Fallback to PCMPlayer
                    player = new PCMPlayer({
                        encoding: '16bitInt',
                        channels: 1,
                        sampleRate: 48000,
                        flushingTime: 100
                    });
                    log("PCM player initialized as fallback");
                    rxAudioInitialized = true; // Mark as initialized even though we're using fallback

                    // Request audio data from the server after initialization
                    if (session_id !== 'nullsession') {
                        websocket_send("audio");
                    }
                }
            } else {
                log("RX audio already initialized");
                // Ensure we're requesting audio data
                if (session_id !== 'nullsession') {
                    websocket_send("audio");
                }
            }
        } catch (e) {
            log("RX audio initialization error: " + e);
            // Last resort fallback
            try {
                player = new PCMPlayer({
                    encoding: '16bitInt',
                    channels: 1,
                    sampleRate: 48000,
                    flushingTime: 100
                });
                log("PCM player initialized as emergency fallback");
                rxAudioInitialized = true;

                // Request audio data from the server
                if (session_id !== 'nullsession') {
                    websocket_send("audio");
                }
            } catch (fallbackError) {
                log("Critical audio error: " + fallbackError);
            }
        }
    }

    window.sbitxMic = window.sbitxMic || {
        enabled: false,
        initialized: false,
        stream: null,
        context: null,
        workletNode: null,        // AudioWorklet node
        buffer: [],
        bufferSize: 512,          // Buffer size for audio processing
        bufferThreshold: 256,     // Send when buffer reaches this size
        sendIntervalMs: 50,       // Send interval in milliseconds
        sendInterval: null,       // Interval reference
        lastSendTime: 0,          // Timestamp of last audio send
        initCount: 0              // Track initialization attempts
    };

    async function initBrowserMic() {
        // Track initialization attempts
        window.sbitxMic.initCount++;
        console.log("Browser mic initialization attempt #" + window.sbitxMic.initCount);

        // Skip if already initialized
        if (window.sbitxMic.initialized && window.sbitxMic.stream) {
            console.log("Browser microphone already initialized, skipping");
            return;
        }

        try {
         // Request microphone access
         if ('audioSession' in navigator) {
                navigator.audioSession.type = 'play-and-record';
            }
            const stream = await navigator.mediaDevices.getUserMedia({
                audio: {
                    sampleRate: 8000,
                    channelCount: 1,
                    echoCancellation: false, // Disable echo cancellation to prevent audio ducking
                    noiseSuppression: false, // Disable noise suppression to prevent audio ducking
                    autoGainControl: false, // Disable auto gain control to prevent audio ducking
                    latency: 0,
                    deviceId: 'default'
                }
            });
            if ('audioSession' in navigator) {
                navigator.audioSession.type = 'playback';
            }

            // Initialize audio context
            window.sbitxMic.stream = stream;
            window.sbitxMic.context = new (window.AudioContext || window.webkitAudioContext)();
            window.sbitxMic.initialized = true; // Mark as initialized
            console.log("Audio context sample rate: " + window.sbitxMic.context.sampleRate + "Hz");

            // Load the audio worklet module
            try {
                await window.sbitxMic.context.audioWorklet.addModule('micProcessor.js');
                console.log("AudioWorklet module loaded successfully");

                // Create audio nodes
                const source = window.sbitxMic.context.createMediaStreamSource(stream);
                window.sbitxMic.workletNode = new AudioWorkletNode(
                    window.sbitxMic.context,
                    'mic-audio-processor'
                );

                // Connect the audio processing chain
                source.connect(window.sbitxMic.workletNode);
                window.sbitxMic.workletNode.connect(window.sbitxMic.context.destination);

                // Handle messages from the processor
                window.sbitxMic.workletNode.port.onmessage = (event) => {
                    if (in_tx && window.sbitxMic.enabled) {
                        const { audioData } = event.data;

                        // Add processed audio to buffer for sending
                        for (let i = 0; i < audioData.length; i++) {
                            window.sbitxMic.buffer.push(audioData[i]);
                        }

                        // Limit buffer size to prevent memory issues
                        if (window.sbitxMic.buffer.length > 10000) {
                            window.sbitxMic.buffer = window.sbitxMic.buffer.slice(0, 5000);
                        }
                    }
                };

                console.log("Browser microphone initialized with AudioWorklet");
            } catch (workletError) {
                console.error("Failed to load AudioWorklet, falling back to ScriptProcessor: " + workletError);
                // If AudioWorklet fails, we could add a fallback to ScriptProcessor here
                // But for simplicity, we'll just report the error
                throw workletError;
            }
        } catch (err) {
            console.log("Error accessing microphone: " + err);
            window.sbitxMic.initialized = false;
        }
    }

    // Setup the interval to send audio data at regular intervals
    function setupAudioSendInterval() {
        // Clear any existing interval first
        if (window.sbitxMic.sendInterval) {
            clearInterval(window.sbitxMic.sendInterval);
            window.sbitxMic.sendInterval = null;
        }

        // Create the interval directly with an inline function
        window.sbitxMic.sendInterval = setInterval(function () {
            if (in_tx && window.sbitxMic.enabled && socket && socket.readyState === WebSocket.OPEN) {
                var now = Date.now();
                if (window.sbitxMic.buffer.length >= window.sbitxMic.bufferThreshold ||
                    (now - window.sbitxMic.lastSendTime > 200 && window.sbitxMic.buffer.length > 0)) {
                    // Take what we have in the buffer, up to bufferSize
                    var samplesToSend = Math.min(window.sbitxMic.buffer.length, window.sbitxMic.bufferSize);
                    var dataToSend = window.sbitxMic.buffer.slice(0, samplesToSend);
                    window.sbitxMic.buffer = window.sbitxMic.buffer.slice(samplesToSend);

                    // Note: Audio processing is now done in the AudioWorklet
                    // We just need to convert to 16-bit PCM for transmission
                    var pcmData = new Int16Array(dataToSend.length);

                    // Check if we're in the silence period for TX transition
                    var silenceAudio = false;
                    if (window.txSilenceUntil && now < window.txSilenceUntil) {
                        silenceAudio = true;
                        console.log("Silencing TX audio during transition");
                    }

                    for (var i = 0; i < dataToSend.length; i++) {
                        // If in silence period, use zero samples
                        if (silenceAudio) {
                            pcmData[i] = 0;
                        } else {
                            // Apply soft clipping to prevent harsh distortion
                            var sample = dataToSend[i];
                            if (sample > 0.8) {
                                sample = 0.8 + (sample - 0.8) / (1 + Math.pow((sample - 0.8) / 0.2, 2));
                            } else if (sample < -0.8) {
                                sample = -0.8 - ((-sample) - 0.8) / (1 + Math.pow(((-sample) - 0.8) / 0.2, 2));
                            }

                            pcmData[i] = Math.round(sample * 32767);
                        }
                    }

                    // Clear the silence flag if we've passed the time
                    if (window.txSilenceUntil && now >= window.txSilenceUntil) {
                        window.txSilenceUntil = null;
                        console.log("TX audio transition complete");
                    }

                    // Send the audio data to the server
                    socket.send(pcmData.buffer);
                    window.sbitxMic.lastSendTime = now;
                }
            }
        }, window.sbitxMic.sendIntervalMs);
    }

    function move_caret(elem, caretPos) {

        if (elem != null) {
            if (elem.createTextRange) {
                var range = elem.createTextRange();
                range.move('character', caretPos);
                range.select();
            }
            else {
                if (elem.selectionStart) {
                    elem.focus();
                    elem.setSelectionRange(caretPos, caretPos);
                }
                else
                    elem.focus();
            }
        }
    }



    //user interaction handlers

    function open_panel(panel) {
        //	$(".sbitx-panel").hide();
        var active_panel = $("#" + panel);
        if (active_panel == undefined)
            return;
        $("#" + panel).show();
        if (window[panel + "_open"] == undefined)
            return;
        window[panel + "_open"]();
    }

    function close_panel(event) {
        //extract the panel name from the parent
        var panel = event.currentTarget.parentElement;
        panel.style.display = "none";
        draw_dial(); //fwiw
        if (window[panel.id + "_close"] == undefined)
            return;
        window[panel.id + "_close"]();
    }

    function sbitx_button_clicked(event) {
        websocket_send(event.currentTarget.id);
    }


    function sbitx_selection_changed(event) {
        var e = event.currentTarget;
        var id_reading = e.id + "_reading";
        if (e.id === "BAND") {
            log("Sending band command: " + e.value); // Debug log
            websocket_send(e.value); // Send just the band value, e.g., "20M"
        } else if (e.id === "RIT" && e.value == "ON") {
            websocket_send("rit" + " " + "on"); // Original behavior for other selects
        } else if (e.id === "RIT" && e.value == "OFF") {
            websocket_send("rit" + " " + "off"); // Original behavior for other selects
        } else {
            log("Sending command: " + e.id + " " + e.value); // Debug log
            websocket_send(e.id + " " + e.value); // Original behavior for other selects
        }
        draw_dial();
    }
    function sbitx_slider_update(e) {
        var id_reading = e.id + "_reading";
        if (el(id_reading)) {
            if (el(id_reading).innerHTML != e.value)
                el(id_reading).innerHTML = e.value;
        }
        draw_dial();
    }

    function sbitx_text_changed(event) {
        var e = event.currentTarget;

        if (e.id === "BFO") {
            var slider = el("slider_BFO");
            slider.value = e.value;

            var currentTime = Date.now();
            var timeSinceLastAdjustment = currentTime - lastBFOAdjustmentTime;

            // Only send menu 1 if more than 5 seconds have passed since last adjustment
            if (timeSinceLastAdjustment > 5000) {
                //console.log("BFO text input: Sending menu 1 command (5+ seconds since last adjustment)");
                websocket_send("menu 1");
                // Add a slight pause between commands
                setTimeout(function() {
                //    console.log("BFO text input: Now sending BFO command");
                    websocket_send("BFO " + e.value);
                }, 200);
            } else   {
                //console.log("BFO text input: Skipping menu 1 command (last adjustment was " + Math.round(timeSinceLastAdjustment/1000) + " seconds ago)");
                websocket_send("BFO " + e.value);
            }

            // Update the last adjustment time
            lastBFOAdjustmentTime = currentTime;
            return;
        }

        websocket_send(e.id + " " + e.value);
    }

    function sbitx_slider_changed(event) {
        var e = event.currentTarget;

        if (e.id == "HIGH") {
            var low = el("LOW");
            if (parseInt(low.value) > parseInt(e.value) + 200) {
                if (parseInt(e.value) > 400)
                    low.value = parseInt(e.value) - 200;
                else
                    low.value = e.value;
                websocket_send("LOW " + low.value);
            }
        }
        if (e.id == "LOW") {
            var high = el("HIGH");
            if (parseInt(high.value) < parseInt(e.value)) {
                if (parseInt(e.value) < 3800)
                    high.value = parseInt(e.value) + 200;
                else
                    high.value = e.value;
                websocket_send("HIGH" + high.value);
            }
        }

        websocket_send(e.id + " " + e.value);
        sbitx_slider_update(e);
    }

    function sbitx_toggle_clicked(e) {

        var btn = event.currentTarget;
        if (!btn.classList.contains('sbitx-toggle'))
            return;
        var cmd = btn.id.substring('toggle_'.length);
        if (el(cmd).value == "OFF")
            websocket_send(cmd + " ON");
        else
            websocket_send(cmd + " OFF");
    }

    function sbitx_toggle_update(e) {

        var element = el('toggle_' + e.id);
        if (element == null)
            return;
        if (element.type == 'checkbox') {
            if (e.value == "ON")
                element.checked = true;
            else
                element.checked = false;
        }
        else {
            if (e.value == 'ON') {
                element.innerHTML = e.id + " ON";
                element.style.backgroundColor = "yellow";
                element.style.color = "black";
            }
            else {
                element.innerHTML = e.id + " OFF";
                element.style.backgroundColor = "#555";
                element.style.color = "white";
            }
        }
        log("toggle updated");
        draw_dial();
    }

    function sbitx_list_select(event) {
        var message = event.currentTarget.innerHTML;

        event.currentTarget.classList.add("wsjtx-selected-message");
        log(message);
    }



    function switch_to_tx() {
        // Set UI state immediately
        log("setting in_tx true");
        $("#tx_meters").show();
        in_tx = true;

        // Clear the RX audio buffer
        if (rxAudioInitialized && rxWorkletNode) {
            rxWorkletNode.port.postMessage({ command: 'clear_buffer' });
            log("RX audio buffer cleared");
        }

        // Set a flag to silence the first 100ms of TX audio
        window.txSilenceUntil = Date.now() + 100; // 100ms silence
        log("TX audio silenced for transition");

        // Resume microphone audio context if it's suspended
        if (micContext && micContext.state === 'suspended') {
            micContext.resume();
        }
    }


    function switch_to_rx() {
        $("#tx_meters").hide();
        log("setting in_tx false");
        in_tx = false;

        // Clear any lingering TX audio data
        if (window.sbitxMic && window.sbitxMic.buffer) {
            window.sbitxMic.buffer = [];
        }

        // Clear any TX silence timing
        window.txSilenceUntil = null;

        // Request fresh audio data from the server
        if (session_id !== 'nullsession' && rxAudioInitialized) {
            websocket_send("audio");
        }
    }

    /* FTx functionality */

    var ft8_tx_count = 0;
    var ft8_tx_on_even = true;
    var ft8_tx_message = "";

    function deco_strip(text) {
        return text.replace(/#./g, '');
    }

	// Selected unique style codes from hist_disp.c
	const STYLE_LOG = 'F'; // generic; also several FTX-specific fields
	const STYLE_MYCALL = 'Q';
	const STYLE_CALLER = 'R';
	const STYLE_GRID = 'S';
	const STYLE_DISTANCE = 'U';
	const STYLE_AZIMUTH = 'V';
	const STYLE_FTX_RX = 'G'; // time, pitch
	const STYLE_SNR = 'H';
	const STYLE_FTX_QUEUED = 'O';
	const STYLE_FTX_REPLY = 'P'; // country
	const STYLE_CW_RX = 'J';
	const STYLE_CW_TX = 'K';
	const STYLE_FLDIGI_RX = 'L';
	const STYLE_FLDIGI_TX = 'M';
	const STYLE_TELNET = 'N';

	function deco_get_style(text) {
		let i = text.indexOf('#');
		if (i >= 0 && text.length > i+1)
			return text.slice(i + 1, i + 2);
		return STYLE_LOG;
	}
	function deco_to_span(text) {
		let jclass = "";
		switch (deco_get_style(text)) {
			case STYLE_LOG:
				jclass = "ftx-generic";
				break;
			case STYLE_MYCALL:
				jclass = "ftx-mycallsign";
				break;
			case STYLE_CALLER:
				jclass = "ftx-caller";
				break;
			case STYLE_GRID:
				jclass = "ftx-grid";
				GRIDMAP.gridIdNotLogged(text.substring(2));
				break;
			case STYLE_DISTANCE:
				jclass = "ftx-distance";
				GRIDMAP.gridIdNotLogged(text.substring(2));
				break;
			case STYLE_AZIMUTH:
				jclass = "ftx-azimuth";
				GRIDMAP.gridIdNotLogged(text.substring(2));
				break;
			case STYLE_FTX_QUEUED:
				jclass = "ftx-queued";
				break;
			case STYLE_FTX_REPLY:
				jclass = "ftx-reply";
				break;
			case STYLE_CW_RX:
			case STYLE_FTX_RX:
			case STYLE_FLDIGI_RX:
			case STYLE_TELNET:
				jclass = "data_rx";
				break;
			case STYLE_CW_TX:
			case STYLE_FLDIGI_TX:
				jclass = "data_tx";
				break;
			default:
				jclass = "list-default";
				break;
		}
		return "<span class='" + jclass + "'>" + deco_strip(text) + "</span>";
	}

	function FT8_stylize_message_item(item, text, style) {
		console.log("FTx style", style, "len", text.length, text);
		var recipient = "";
		var sender = "";
		var htmMessage = "";

		// find the #<letter> tags and build up htmMessage with spans
		var prev_pos = 0;
		while (prev_pos >= 0) {
			let hash_pos = text.indexOf('#', prev_pos + 1);
			if (hash_pos > 0 || prev_pos > 0)
				htmMessage += deco_to_span(text.slice(prev_pos, hash_pos < 0 ? text.length : hash_pos).replaceAll(" ", "&nbsp;"));
//~ 			console.log("hash @", hash_pos, "prev_pos", prev_pos, "now we have", htmMessage);
			prev_pos = hash_pos;
		}
		// special case for one long span
		if (htmMessage.length == 0 && text.length > 0)
			htmMessage = deco_to_span(text.replaceAll(" ", "&nbsp;"));
//~ 		console.log("emitting", htmMessage);

		if (style == 'Q') { // queued to send
			item.className = "sbitx-list-item ftx-queued";
		} else if (style == 'TX') { // sending now
			item.className = "sbitx-list-item ftx-tx";
		} else { // e.g. style == "RX"
			item.className = "sbitx-list-item";
		}
		item.innerHTML = '<span class="ft8-message">' + htmMessage + '</span>';
	}

    function FT8_list_append(list_id, line, text, style){
        var item = document.createElement("li");
        FT8_stylize_message_item(item, text, style);
        item.id = line >= 0 ? (line).toString() : deco_strip(text).replace(/[^\w\-\/\~\.]+/g, "_");
        el(list_id).children[0].appendChild(item);
        item.scrollIntoView({ behaviour: 'smooth', block: 'nearest' });
    }

    function FT8_transmit(message) {
        websocket_send("key " + message + "\n");
        log("FT8 tx: " + message);
        // FT8_list_append("wsjtx-rx", message);
    }

    function FT8_cq(event) {
        logger_wipe();
        logger_abort();
        var cq_type = el("ft8_cq_kindof").value;
        FT8_transmit(cq_type + " " + el("MYCALLSIGN").value.toUpperCase()
            + " " + el("MYGRID").value.substring(0, 4).toUpperCase());
    }

	// You can choose any message that has a positive ID: the console line number.
	// TX messages do not have them.
	function FT8_message_chosen(event) {
		var li = event.target.closest('.sbitx-list-item');
		log(li)
		var id = parseInt(li.id);
		console.log("chose message with ID", li.id, id);
		if (isNaN(id) || id < 0)
			return;

		if (event.altKey) { // shift click
			// TODO pull out the grid by its #S tag
			/*
			if (token_list.length == 9) { // cq dx call grid
				show_in_qrz_window(token_list[7]);
			} else { // cq call grid || to call grid
				show_in_qrz_window(token_list[6]);
			}
			*/
		} else {
			websocket_send("selectline " + li.id);
		}
	}

    function FT8_lists_clear() {
        document.querySelector('#wsjtx-activity ol').innerHTML = "";
        document.querySelector('#wsjtx-rx ol').innerHTML = "";
        console.log("FT8 lists cleared");
    }
    function FT8_new_message(line, text, style) {
        // log("ft8: line " + line + ": " + text + ":" + style);
        FT8_list_append("wsjtx-activity", line, text, style);
        var mycallsign = $("#MYCALLSIGN").val().toUpperCase();
        if (text.search(mycallsign) >= 0)
            FT8_list_append("wsjtx-rx", line, text, style);
    }

    // setup the html for wsjtx
    function FT8_open() {

        el("FT8_ui").style.display = "block";
    }

    /* cw functionality */

    function cw_open(mode) {
        if (document.location.hostname == "127.0.0.1")
            el("keybd").style.display = "block";
        text_focus = el("data_window");
        if (mode == 'RTTY' || mode == 'PSK31') {
            $("#data_chat").show();
            $("#cw_settings").hide();
        }
        else {
            $("#data_chat").hide();
            $("#cw_settings").show();
        }
        var b = $("body");
        if (b.height() > 600)
            el("data_window").styleheight = 50;
    }

    //the keystrokes, as they transfer to the sdr backend
    //are color coded into different colored spans

    function cw_keydown(c) {
        //we changed this from being an evernt handler
        //var c = event.key;

        if (el("MODE").value != "CW" && el("MODE").value == "CWR" &&
            el("MODE").value != "PSK31" && el("MODE").value != "RTTY")
            return;

        if (c == "Shift" || c == "Alt") {
            logger_abort();
            return;
        }
        else if (c == 'Escape') {
            logger_abort();
            return;
        }
        else if (c == 'Backspace')
            c = String.fromCharCode(8);
        else if (c.length > 1)
            return;

        log("user typed cw letter [" + event.key + "], sending to sdr");
        websocket_send("key " + c);
    }

    function cw_input_focus(event) {
        text_focus = event.currentTarget;
    }

    function cw_update(text, kindof) {
        var rx_window = el("data_window");
        var text_done = el("text_done");
        // ignore newline from CW: <span>\n</span> looks the same as a space.
        // If we wanted a real break, we'd need to use <BR/> here.
        if (text.match(/^#[JK][\n\r]+$/))
           return;
        text_done.innerHTML = text_done.innerHTML + deco_to_span(text);
        rx_window.scrollTop = rx_window.scrollHeight;
    }

    function data_tx(event) {
        websocket_send("t ");
        text_focus = el("data_window");
    }

    function data_rx(event) {
        websocket_send("r ");
        el("data_window").focus;
    }

    /* console functionality */

    function console_update(text) {
        var window = el("console_window");
        window.innerHTML = window.innerHTML + text;
        window.scrollTop = window.scrollHeight;
    }

    function show_console_panel() {
        open_panel("console_panel");
    }

    /* telnet functionality */

    function telnet_update(text) {
        const window = el("telnet_window");
        const MAX_LINES = 100; // Maximum number of lines to display
        let lines = window.innerHTML ? window.innerHTML.split('\n') : []; // Current lines

        // Split new text into lines and filter out empty ones
        const newLines = text.split('\n').filter(line => line.trim());

        // Add new lines to the FIFO buffer
        lines.push(...newLines);

        // Trim oldest lines if exceeding MAX_LINES
        if (lines.length > MAX_LINES) {
            lines = lines.slice(lines.length - MAX_LINES);
        }

        // Update window content
        window.innerHTML = lines.join('\n');
        window.scrollTop = window.scrollHeight;

        // Existing spot parsing logic remains unchanged
        const word = text.split(' ');
        let i = 0;
        if (word[i] !== 'DX') return;
        i++;
        while (word[i] === '') i++;

        if (word[i] !== 'de') return;
        i++;
        while (word[i] === '') i++;

        i++; // Skip the spotter's callsign
        while (word[i] === '') i++;

        const freq = parseInt(word[i++]);
        while (word[i] === '') i++;

        const call = word[i++];
        while (word[i] === '') i++;

        const mode = word[i];

        const currentTime = Date.now();
        const s = {
            frequency: freq,
            callsign: call,
            mode: mode,
            timestamp: currentTime
        };

        spots.unshift(s);

        const MAX_SPOTS = 1000;
        if (spots.length > MAX_SPOTS) {
            spots.pop();
        }

        const SPOT_TIMEOUT = 300000;
        while (spots.length > 0 && currentTime - spots[spots.length - 1].timestamp > SPOT_TIMEOUT) {
            spots.pop();
        }
    }

    function show_telnet_panel() {
        open_panel("telnet_panel");
    }

    /* voice functionality */
    function voice_open() {
        //	el("spectrum").height =  150;
        //	el("waterfall").height = 150;
    }

    function ptt_tx(event) {
        websocket_send("t ");
    }

    function ptt_rx(event) {
        websocket_send("r ");
    }

    /* logger functionality */


    function logger_wipe(event) {
        websocket_send("ABORT");
        $("CALL").val("");
        $("SENT").val("");
        $("RECV").val("");
        $("EXCH").val("");
        $("NR").val("");
    }

    function logger_abort(event) {
        websocket_send("abort=1");
    }

    function show_in_qrz_window(callsign) {
        var url = "https://www.qrz.com/db/" + callsign;
        if (qrz_window == null || qrz_window.closed)
            qrz_window = window.open(url, "_blank");
        else
            qrz_window.location = url;
    }
    function logger_qrz(event) {
        if ($("#CALL").val().length < 2)
            return;

        show_in_qrz_window($("#CALL").val());
    }

    function logbook_open(event) {
        //	var url = "https://www.qrz.com/db/" + $("#CALL").val();
        var url = window.location.origin + "/logbook.html";

        if (log_window == null)
            log_window = window.open(url, "log");
        else //if (log_window.closed)
            log_window = window.open(url, "log");
        //else
        //log_window.location = url;
    }
    function logger_enter_qso() {
        var contact_callsign = el("CALL").value.toUpperCase();
        var rst_sent = el("SENT").value.toUpperCase();
        var exchange_sent = el("NR").value.toUpperCase();
        var rst_recv = el("RECV").value.toUpperCase();
        var exchange_recv = el("EXCH").value.toUpperCase();
        if (contact_callsign.length < 2 || !rst_sent.length || !rst_recv.length) {
            alert("Fill the logger callsign, RST sent, received to save the QSO");
            return;
        }
        websocket_send("qso=" + contact_callsign + "|" + rst_sent + "|" + exchange_sent
            + "|" + rst_recv + "|" + exchange_recv);
        logger_wipe();
        setTimeout(logbook_reload, 500);
    }

    function logger_trigger_macro(event) {
        websocket_send(event.id);
    }

    function logger_bind_key(fn_key, macro_line) {
        //extract the key name
        var key_name = "";
        var i;
        for (i = 0; i < macro_line.length; i++)
            if (macro_line.charAt(i) == ',')
                break;
        if (i == 0 || i == macro_line.length)
            return;
        if (fn_key) {
            var e = el(fn_key);
            if (e != null) {
                el(fn_key).innerHTML = e.id + "<br>" + macro_line.substring(0, i);
                el(fn_key).dataset.macro_text = macro_line.substring(i + 1);
            }
        }
    }

    //we expect the macro file to be in n1mm format
    function logger_keys_update() {
        var lines = macros_file.split("\n");
        for (var i = 0; i < lines.length; i++) {
            var line = lines[i];
            //we deal only with the lines that start with 'FN ' or 'FNN '
            if (line.charAt(0) == 'F' && isdigit(line.charAt(1))) {
                if (isdigit(line.charAt(2)) && line.charAt(3) == ' ')
                    logger_bind_key(line.substring(0, 3), line.substring(4));
                else if (line.charAt(2) == ' ')
                    logger_bind_key(line.substring(0, 2), line.substring(3));
            }
        }
    }

    function logger_set_macro(macro_file_name) {
        current_macro = macro_file_name;
        if (el("MACRO").value != macro_file_name)
            el("MACRO").value = macro_file_name;
        jQuery.get("/" + macro_file_name + ".mc", function (data) { macros_file = data; logger_keys_update(); });
    }

    function logger_get_macro_file(event) {
        var macro_file_name = event.currentTarget.value;
        logger_set_macro(macro_file_name);
    }

    function logger_toggle_macros(event) {
        if (el("logger-macros").style.display == "block") {
            el("logger-macros").style.display = "none";
            return;
        }
        el("logger-macros").style.display = "block";
        var macro_file_name = el("MACROS_list").value
        jQuery.get("/" + macro_file_name + ".mc", function (data) { macros_file = data; logger_keys_update(); });
    }

    function logger_list_macros(list) {
        var names = list.split("|");
        var sel = el("MACRO");
        sel.innerHTML = "";
        for (var i = 0; i < names.length; i++)
            if (names[i].length > 0)
                sel.appendChild(new Option(names[i], names[i]));
        // Set to the current macro value if we have one stored
        if (current_macro) {
            for (var i = 0; i < sel.options.length; i++) {
                if (sel.options[i].value === current_macro) {
                    sel.value = current_macro;
                    // Load the macro file and update the buttons
                    logger_set_macro(current_macro);
                    break;
                }
            }
        }
    }

    // trigged when the back sdr changes the macros
    function logger_macro_changed_from_sdr(new_macro) {
        current_macro = new_macro;
        if (el("MACRO").value == new_macro)
            return;
        el("MACRO").value = new_macro;
        websocket_send("macro_labels=" + new_macro);
    }

    /* logbook
    web api:
        logbook=0 loads the last 50 qsos
        any +ve number loads 50 qsos with earlier
    */

    function logbook_update(args) {
        var token = args.split("|");
        var insert_index = 0; //at the top
        if (token.length < 10)
            return;

        var qso_id = token[0];

        if (logbook_top_row_id < Number(qso_id))
            logbook_top_row_id = Number(qso_id);
        if (logbook_bottom_row_id > Number(qso_id)) {
            logbook_bottom_row_id = Number(qso_id);
            insert_index = -1; //insert at the bottom
        }

        var table = $("#logbook_table tbody")[0];

        //replace existing row?
        var row = el("logentry-" + token[0]);
        if (row == null) {
            row = table.insertRow(insert_index);
            row.id = "logentry-" + token[0];
        } else {
            for (var i = 0; i < 8; i++)
                row.deleteCell(-1);
        }

        //date and time are at position 3, 4
        item = row.insertCell(-1);
        item.innerHTML = qso_id;
        item.className = "logbook-field logbook-serial";

        item = row.insertCell(-1);
        item.innerHTML = token[3] + ' ' + token[4];
        item.className = "logbook-field logbook-datestamp";
        //frequency
        item = row.insertCell(-1);
        item.innerHTML = token[2];
        item.className = "logbook-field logbook-freq";
        //mode
        item = row.insertCell(-1);
        item.innerHTML = token[1];
        item.className = "logbook-field logbook-mode";
        //callsign
        item = row.insertCell(-1);
        item.innerHTML = token[8];
        item.className = "logbook-lfield logbook-call";
        //sent
        item = row.insertCell(-1);
        item.innerHTML = token[6] + '  ' + token[7];
        item.className = "logbook-field logbook-sent";
        //received
        item = row.insertCell(-1);
        item.innerHTML = token[9] + '  ' + token[10];
        item.className = "logbook-field logbook-recv";
    }

    function logbook_reset() {
        $("#logbook_table tbody")[0].innerHTML = "";
        logbook_bottom_row_id = 10000000;
        logbook_top_row_id = 0;
    }

    function open_logbook(event) {
        open_panel("logbook_panel");
    }

    function close_logbook(event) {

    }
    //ask for qso made after a particular qso id
    //or qso made prior to a particular qso_id (prior is minus)
    function logbook_request(qso_id) {
        var q = "logbook=" + Number(qso_id);
        if (el("logbook-search").value.length > 0)
            q += " " + el("logbook-search").value.toUpperCase();
        websocket_send(q);
    }

    function logbook_more() {
        logbook_request(logbook_bottom_row_id);
    }

    function logbook_search() {
        logbook_reset();
    }

    function open_logbook(event) {
        open_panel("logbook_panel");
    }


    /* settings panel */

    function open_settings() {
        open_panel("settings_panel");
        //set the focs to the pin
        el("PASSKEY").focus();
    }

    function open_menu() {
        open_panel("menu_panel");

    }

    function save_settings() {
        websocket_send("MYCALLSIGN " + el("MYCALLSIGN").value);
        websocket_send("MYGRID " + el("MYGRID").value);
        websocket_send("PASSKEY " + el("PASSKEY").value);
        websocket_send("SIDETONE " + el("SIDETONE").value);
        websocket_send("TELNETURL " + el("TELNETURL").value);
        $("#settings_panel").hide();
    }

    function close_settings() {

        $("#settings_panel").hide();
    }


    /* recorder panel */

    var record_started = -1;

    function open_recorder() {
        open_panel("recorder_panel");
    }

    function start_recorder() {
        websocket_send("REC ON");
    }

    function stop_recorder() {
        websocket_send("REC OFF");
        el("recorder_panel").style.display = "";
    }

    function update_recorder() {
        if (record_started == -1)
            el("record_duration").innerHTML = "00:00";
        else {
            seconds = Math.round(Date.now() / 1000) - record_started;
            minutes = Math.round(seconds / 60);
            seconds = Math.round(seconds % 60);
            el("record_duration").innerHTML = ("0" + minutes).slice(-2)
                + ":" + ("0" + seconds).slice(-2);
        }
    }

    /* switching the ui for different modes */

    // response from the sdr

    function update_data(text) {
        var xml = parser.parseFromString("<updates>" + text + "</updates>", "text/xml");
        if (xml != null) {
            var wsjtx = xml.getElementsByTagName("WSJTX-RX");
            if (wsjtx)
                for (var i = 0; i < wsjtx.length; i++) {
                    var line_n = wsjtx[i].getAttribute("l");
                    if (wsjtx[i].innerHTML.length > 30)
                        FT8_new_message(line_n, wsjtx[i].innerHTML, "RX");
                }

            //read the QSO specific ones too
            wsjtx = xml.getElementsByTagName("WSJTX-TX");
            if (wsjtx)
                for (var i = 0; i < wsjtx.length; i++)
                    if (wsjtx[i].innerHTML.length > 30)
                        FT8_new_message(-1, wsjtx[i].innerHTML, "TX");

            //read tx message in the Q
            wsjtx = xml.getElementsByTagName("WSJTX-Q");
            if (wsjtx)
                for (var i = 0; i < wsjtx.length; i++)
                    if (wsjtx[i].innerHTML.length > 30)
                        FT8_new_message(-1, wsjtx[i].innerHTML, "Q");

            var data = xml.getElementsByTagName("TELNET");
            if (data && in_tx == false)
                for (var i = 0; i < data.length; i++)
                    telnet_update(data[i].innerHTML, "telnet");

            var data = xml.getElementsByTagName("FLDIGI-RX");
            if (data && in_tx == false)
                for (var i = 0; i < data.length; i++)
                    cw_update(data[i].innerHTML, "data_rx");

            var data = xml.getElementsByTagName("FLDIGI-TX");
            if (data && in_tx == true)
                for (var i = 0; i < data.length; i++)
                    cw_update(data[i].innerHTML, "data_tx");

            var data = xml.getElementsByTagName("CW-TX");
            if (data)
                for (var i = 0; i < data.length; i++)
                    cw_update(data[i].innerHTML, "data_tx");

            var data = xml.getElementsByTagName("CW-RX");
            if (data)
                for (var i = 0; i < data.length; i++)
                    cw_update(data[i].innerHTML, "data_rx");

            var data = xml.getElementsByTagName("LOG");
            for (var i = 0; i < data.length; i++) {
                let s = data[i].innerHTML;
                write_console(s);
                // Extract qso grid from message e.g.
                // "Logged: F4VTG -05-JO65 -14-JN12\n;"
                if (s.startsWith("Logged:")) { // String ends width \n
                    s = s.substring(s.length - 5, s.length - 1);
                    GRIDMAP.gridIdJustLogged(s);
                }
            }
        }
        else
            console_update(text);
        //		el("log").insertAdjacentHTML("beforeend", text);
    }

    var ticks = 0;
    function ui_tick() {
        if (socket == null)
            return;

        //recorder update if it is running
        if (record_started != -1)
            update_recorder();

        if (socket.readyState != 1)
            return;
        if (session_id == 'nullsession')
            return;
        if (rxAudioInitialized && !sound_mute)
            websocket_send("audio");
        else
            websocket_send("spectrum");

        ticks++;
        if (ticks % 10 == 0)
            logbook_request(-logbook_top_row_id);
    }

    function show_selected_band_store(args) {
        // Update the BAND dropdown to reflect the selected band
        var band_map = {
            '0': '80M',
            '1': '60M',
            '2': '40M',
            '3': '30M',
            '4': '20M',
            '5': '17M',
            '6': '15M',
            '7': '12M',
            '8': '10M'
        };
        const bandEl = el("BAND");
        if (bandEl && band_map[args]) {
            bandEl.value = band_map[args];
        }
        const selbandEl = el("SELBAND");
        if (selbandEl) {
		    selbandEl.innerText = band_stack_indicators[args] || " ";
        }
    }
    function mode_set(new_mode) {

        var wf = el("waterfall");
        var sp = el("spectrum");
        wf.height = 100;
        sp.height = 100;
        cachedGradient = null;

        $(".mode-panel").hide();

        if (new_mode === 'CW' || new_mode === 'CWR' || new_mode === 'FT8' || new_mode === 'FT4' || new_mode === 'DIGI') {
            $(".cw-ft8-control").show();
        } else {
            $(".cw-ft8-control").hide();
        }
        switch (new_mode) {
            case 'CW':
            case 'CWR':
                wf.height = 150;
                sp.height = 100;
                cw_open(new_mode);
                $("#CW_ui").show();
                $("#more_keys").show();
                logger_set_macro("CW1");
                break;
            case "AM":
            case "LSB":
            case "USB":
            case "2TONE":
                wf.height = 225;
                sp.height = 125;
                $("#Voice_ui").show();
                $("#more_keys").hide();
                break;
            case "DIGI":
                wf.height = 150;
                sp.height = 100;
                $("#digi_ui").show();
                $("#more_keys").hide();
                break;
            case 'FT4':
            case 'FT8':
                sp.height = 50;
                wf.height = 50;
                FT8_open();
                $(".FT8_ui").show();
                $("#more_keys").show();
                logger_set_macro("FT8");
                //sound_mute = false;
                break;
            default:
                wf.height = 150;
                var panel_name = "#" + new_mode + "_ui";
                var active_panel = $(panel_name);
                $("#more_keys").hide();
                logger_set_macro("CW1");
                if (active_panel.length > 0)
                    $(panel_name).show();
                return;
        }
        //	if (window[new_mode+"_open"] == undefined)
        //		return;
        //	window[new_mode + "_open"]();
    }

    function mode_changed(event) {
        mode_set(event.currentTarget.value);
    }

    var prev_sample = 0;
    var intp_factor = 3;

    // Waterfall throttling variables
    var lastWaterfallUpdate = 0;
    var waterfallUpdateInterval = 200; // Update every 100ms (adjust to slow more/less)

    //audio interpolation variables
    var prev_sample = 0;
    var intp_factor = 3;
    function response_handler(response) {
        var cmd = "";
        var args = "";

        // Function to update linear control values
        function updateLinearControl(id, value) {
            // Update hidden input
            const hiddenInput = document.getElementById(id + '_hidden');
            if (hiddenInput) {
                hiddenInput.value = value;
            }

            // Update visible control and slider
            const control = document.getElementById(id);
            if (control) {
                control.value = value;
                const slider = document.getElementById('slider_' + id);
                if (slider) {
                    slider.value = value;
                }
            }
        }

        // Function to update S-meter display
        function updateSMeter(s_units, additional_db) {
            const boxes = document.querySelectorAll('.smeter-box');
            boxes.forEach(box => {
                const level = parseInt(box.dataset.level) || 20;
                if (level === 20) {
                    // Special case for 20+ box
                    box.classList.toggle('active', s_units >= 9 && additional_db > 0);
                } else {
                    box.classList.toggle('active', s_units >= level);
                }
            });
        }

        // Handle binary data (audio samples)
        if (response instanceof Blob) {
            f = new FileReader();
            f.onload = () => {
                if (!sound_mute) {
                    var samples = new Int16Array(f.result);

                    // If we have the worklet initialized, use it
                    if (rxAudioInitialized && rxWorkletNode) {
                        // Send the raw Int16Array data directly to the worklet
                        rxWorkletNode.port.postMessage(samples.buffer);
                    }
                    // Otherwise fall back to PCMPlayer if available
                    else if (typeof player !== 'undefined' && player) {
                        var upsample = new Int16Array(samples.length * intp_factor);
                        var j = 0;
                        //interpolate, generating higher sampling rate
                        for (var i = 0; i < samples.length; i++)
                            for (var x = 0; x < intp_factor; x++) {
                                upsample[j++] = ((prev_sample * (intp_factor - x - 1))
                                    + (samples[i] * (x + 1))) / intp_factor;
                                prev_sample = samples[i];
                            }
                        player.feed(upsample);
                    }
                }
            }
            f.readAsArrayBuffer(response);
            return;
        }

        // Handle ArrayBuffer data (binary audio data)
        if (response instanceof ArrayBuffer ||
            (typeof response === 'object' && response.constructor &&
                response.constructor.name === 'ArrayBuffer')) {
            if (!sound_mute) {
                var samples = new Int16Array(response);

                // If we have the worklet initialized, use it
                if (rxAudioInitialized && rxWorkletNode) {
                    // Send the raw Int16Array data directly to the worklet
                    rxWorkletNode.port.postMessage(samples.buffer);
                }
                // Otherwise fall back to PCMPlayer if available
                else if (typeof player !== 'undefined' && player) {
                    var upsample = new Int16Array(samples.length * intp_factor);
                    var j = 0;
                    //interpolate, generating higher sampling rate
                    for (var i = 0; i < samples.length; i++)
                        for (var x = 0; x < intp_factor; x++) {
                            upsample[j++] = ((prev_sample * (intp_factor - x - 1))
                                + (samples[i] * (x + 1))) / intp_factor;
                            prev_sample = samples[i];
                        }
                    player.feed(upsample);
                }
            }
            return;
        }

        // Handle string data
        // Make sure response is a string before using string methods
        if (typeof response !== 'string') {
            // Silently ignore non-string, non-binary data
            return;
        }

        if (response.substring(0, 3) == "TX " || response.substring(0, 3) == "RX ") {
            if (response.substring(0, 2) == "TX" && in_tx == false)
                switch_to_tx();
            else if (response.substring(0, 2) == "RX" && in_tx == true)
                switch_to_rx();

            spectrum_update(response);
            if (in_tx == false)
                waterfall_update(response);
            return;
        }

        var i = response.indexOf(' ');
        if (i >= 0) {
            cmd = response.substring(0, i);
            args = response.substring(i + 1);
        }
        else
            return;

        switch (cmd) {
            case 'quit':
                log("Received a quit message");
                session_id = "nullsession";
                socket.close();
                end_login("Logged in from a another device");
                break;
            case 'login':
                if (args != 'error') {
                    session_id = args;
                    document.cookie = "sessionid=" + session_id + ";path=/";
                    log("session_id set to " + session_id);
                    show_main();
                    resize_ui();
                    // Initialize mode state after successful login
                    setTimeout(() => {
                        checkTuneState();
                    }, 500);
                }
                else {
                    alert("Incorrect passkey.\r\nIf you have forgotten your pass key\r\n" +
                        "You can see it in user_settings.ini in sbitx/data folder");
                }
                break;
            case 'QSO':
                logbook_update(args);
                break;
            case 'TEXT':
                log("text: [ " + args + "]");
                el("text_pending").innerHTML = args;
                break;
            case 'CONSOLE':
                update_data(args);
                break;
            case 'SPECTRUM':
            case 'WATERFALL':
                break;
            case 'FREQ':
                e = el(cmd);
                log("freq " + args);
                if (e)
                    e.value = args;
                //update the selected VFO
                if (el("VFO").value == 'A')
                    el("VFOA").value = args;
                else
                    el("VFOB").value = args;
                draw_dial();
                break;
            case 'macros_list':
                logger_list_macros(args);
                break;
            case 'SMETER':
                var parts = args.split(' ');
                if (parts.length === 2) {
                    updateSMeter(parseInt(parts[0]), parseInt(parts[1]));
                }
                break;
            case 'ZEROSENSE':
                updateLinearControl('ZEROSENSE', parseInt(args));
                break;
            case 'VOLTAGE':
                el("VOLTAGE").value = args;
                document.getElementById("voltage_display").textContent = parseFloat(args).toFixed(2) + "V";
                document.getElementById("battery_status").style.display = "block";
                break;
            case 'CURRENT':
                el("CURRENT").value = args;
                document.getElementById("current_display").textContent = parseFloat(args).toFixed(2) + "A";
                document.getElementById("battery_status").style.display = "block";
                break;
            case 'MACRO':
                logger_macro_changed_from_sdr(args);
                break;
            case '10M':
                band_stack_indicators[8] = args;
                break;
            case '12M':
                band_stack_indicators[7] = args;
                break;
            case '15M':
                band_stack_indicators[6] = args;
                break;
            case '17M':
                band_stack_indicators[5] = args;
                break;
            case '20M':
                band_stack_indicators[4] = args;
                break;
            case '30M':
                band_stack_indicators[3] = args;
                break;
            case '40M':
                band_stack_indicators[2] = args;
                break;
            case '60M':
                band_stack_indicators[1] = args;
                break;
            case '80M':
                band_stack_indicators[0] = args;
                break;
            case 'SELBAND':
                if (curBand !== args) {
                    FT8_lists_clear();
                }
                curBand = args;
                show_selected_band_store(args);
                break;
            case "BSTACKPOSOPT":
                if (args == "OFF") {
                    el("STORE").style.display = "none";
                }
                break;
            case 'MODE':
                mode_set(args);
            //There is no break statement here, MODE continues to default case
            default:
                e = el(cmd);
                if (e) {
                    if (e.value != args) {
                        e.value = args;
                        if (e.classList.contains('knob-value'))
                            knob_update(e);
                        else if (e.classList.contains('linear-value'))
                            update_linear(e);
                        else if (e.classList.contains('sbitx-update-toggle'))
                            sbitx_toggle_update(e);
                        else if (cmd == "MYCALLSIGN" && args == "NOBODY")
                            open_settings("settings_panel");
                        else if (cmd == "ZEROBEAT")
                            updateZerobeatDisplay(parseInt(args));
                        else if (cmd == 'SPLIT')
                            draw_dial();
                        if (cmd == "REC") {
                            if (args == "ON")
                                record_started = Math.round(Date.now() / 1000);
                            else
                                record_started = -1;
                            update_recorder();
                        }
                    }

                }
                /*	else
                        log("unhandled " + cmd + " : " + args);
                */

                if (cmd == 'REF') {
                    draw_meters();
                    //				log("meter : " + el("POWER").value + "," + el("REF").value);
                }
        }
    }


    parser = new DOMParser();
    show_login();
    waterfall_init();
    setInterval(ui_tick, 50);
    spots = [];

    //init the event handlers
    window.addEventListener("resize", resize_ui);
    window.addEventListener("click", on_click);
    $(".sbitx-btn").on("click", sbitx_button_clicked);
    $(".sbitxv3-btn").on("click", sbitx_button_clicked);
    //$(".sbitxv3-control").on("click", sbitxv3_control_clicked);
    $(".sbitx-selection").on("change", sbitx_selection_changed);
    $(".sbitx-slider").on("input", sbitx_slider_changed);
    $(".sbitx-toggle").on("click", sbitx_toggle_clicked);
    $(".sbitx-keystroke td").on("click", sbitx_onscreen_key);
    $(".sbitx-panel-title").on("click", close_panel);
    $(".sbitx-text-field").on("change keydown paste input", sbitx_text_changed);
    $(".linear-slider").on("input", on_linear_moved);
    $(".linear").on("click", linear_toggle);
    $(".macro-btn").on("click", logger_trigger_macro);

    //ft8 specific handlers
    $("#wsjtx-activity").on("click", FT8_message_chosen);
    $("#wsjtx-rx").on("click", FT8_message_chosen);

    //specific control handler
    //$("#knob_on").on("click", toggle_dial);

    spectrumEl.addEventListener("mouseup", (event) => { getMousePosition(canvas, event)});
    $("#STORE").on("click", () => { websocket_send(el("BAND").value); });
    $("#sound_mute").on("click", () => {
        sound_mute = !sound_mute;
        el("mute_state").innerHTML = sound_mute ? "ON" : "OFF";
    });
    el("dial").addEventListener("wheel", change_freq, { passive: false });
    $("#REF").on("change", draw_meters);
    $("#MODE").on("change", mode_changed);
    $("#console-open").on("click", show_console_panel);
    $("#telnet-open").on("click", show_telnet_panel);
    $("#keyboard-open").on("click", show_keyboard);
    $("#MACRO").on("change", logger_get_macro_file);
    //vfo buttons
    $("#vfo_reset").on("click", vfo_set);
    $("#vfo_swap").on("click", vfo_set);

    // logger buttons
    $("#wipe").on("click", logger_wipe);
    $("#esc").on("click", logger_abort);
    $("#qrz").on("click", logger_qrz);
    $("#logger-log").on("click", logger_enter_qso);
    //$("#macros").on("click", logger_toggle_macros);
    $("#MACRO").on("change", logger_get_macro_file);
    $(".macro-button").on("click", logger_trigger_macro);
    //function key handlers
    document.addEventListener('keydown', function (e) {
        if (e.key.length > 1 && e.key[0] == 'F' && isdigit(e.key[1])) {
            websocket_send(e.key);
            e.preventDefault();
        }
        else if (e.key == 'Escape') {
            websocket_send("ESC");
            e.preventDefault();
        }
        else if (e.key == "Enter" && text_focus != null && text_focus.id == "text_in") {
            // Special handling for CLEAR command
            if (text_focus.value.toUpperCase() === "CLEAR") {
                FT8_lists_clear(); // Clear the FT8 lists in the web interface
            }
            websocket_send(text_focus.value);
            text_focus.value = "";
        }
        else if (e.key == "Enter" && text_focus != null && text_focus.id == "telnet_in") {
            websocket_send("tel " + text_focus.value);
            text_focus.value = "";
        }
        else if (text_focus.id == "data_window") {
            cw_keydown(e.key);
        }
    });


    $("#start_login").on("click", do_login);
    //cw buttons, also used for chatty data
    $("#data_window").on("click", cw_input_focus);
    $("#data_chat_tx").on("click", data_tx);
    $("#data_chat_rx").on("click", data_rx);
    //$(".sbitxv3-slider").on("click", toggle_slider);
    //ssb buttons
    $("#xpra_launch_digi, #xpra_launch_cw, #xpra_launch_ft8, #xpra_launch_voice").on("click", function() {
        window.open("apps.html", "_blank");
    });
    $("#ptt_tx").on("click", ptt_tx);
    $("#ptt_rx").on("click", ptt_rx);

    //logbook buttons
    $("#logbook-open").on("click", logbook_open);
    $("#btn-logbook-close").on("click", close_logbook);
    $("#btn-logbook-search").on("click", logbook_request);
    $("#btn-logbook-load").on("click", logbook_more);
    $("#logbook-search").on("input", logbook_search);

    //settings buttons
    $("#settings-open").on("click", open_settings);

    $("#menu-open").on("click", open_menu);
    $("#menu-open2").on("click", open_menu);
    $("#menu-open3").on("click", open_menu);
    $("#menu-open4").on("click", open_menu);
    $("#settings_save").on("click", save_settings);
    $("#close_button").on("click", close_settings);


    //recorder buttons
    $("#recorder-open").on("click", open_recorder);
    $("#record_start").on("click", start_recorder);
    $("#record_stop").on("click", stop_recorder);

    window.onload = ui_init();

    //init the state of the ui
    function ui_init() {
        $(".sbitx-text-input").on("focus", sbitx_text_focus);
        $("#tx_rx").hide();
        $(".sbitx-panel").hide();
        $("#extra-controls").hide(); //do something about these
        $("#more_keys").hide(); //do something about these
        logger_set_macro("CW1");
        logbook_reset();
        if (document.location.hostname == "127.0.0.1") {
            //		window.addEventListener("contextmenu", function(e) { e.preventDefault(); }); //uncomment in production
            //		$("#tuning_knob").hide();
        }
        if (document.location.hostname == "127.0.0.1") {
            show_keyboard();
            do_login();
        }
        /*	else
                $("#keybd").hide();*/
    }

    function v3control_number(id, start, stop, step) {
        var c = document.getElementById(id);
        for (var i = start; i <= stop; i += step) {
            var option = document.createElement("option");
            option.text = i.toString();
            option.value = i.toString();
            option.className = "sbitxv3-option";
            c.add(option);
        }
    }

    function sbitxv3_control_clicked(event) {
        //find the nested button or select, just one in the control
        var id = event.currentTarget.getElementsByTagName("select")[0].id;
        var select_control = el(id);
        var options = select_control.options;
        if (options.selectedIndex < options.length - 1)
            select_control.value = options[options.selectedIndex + 1].text;
        else
            select_control.value = options[0].text;

        websocket_send(id + " " + select_control.value);

        // If this is the MODE control, check if we need to disable browser mic
        if (id === "MODE") {
            var mode = select_control.value;
            if ((mode === "FT4" || mode === "FT8" || mode === "DIGI") && window.sbitxMic && window.sbitxMic.enabled) {
                toggleBrowserMic(); // Turn off browser mic
            }
        }
    }


    /* knob control handlers */

    function linear_toggle(event) {
        var drop_id = event.currentTarget.id.substring(7);
        var div_el = event.currentTarget.querySelector(".linear-dropdown");
        log("Toggle!!!!");

        if (div_el.style.display == "block") {
            div_el.style.display = "";
            // Show logger controls again when slider is hidden
            //$("#logger-controls").show();
        } else {
            div_el.style.display = "block";
            // Hide logger controls when slider is shown
            //$("#logger-controls").hide();

            // send this value to the radio to get the focus here
            // this will enable the control encoder to work
            websocket_send(drop_id + " " + el(drop_id).value);
        }
    }



    //when the user changes the value
    // Variable to track the last time BFO was adjusted
    var lastBFOAdjustmentTime = 0;

    function on_linear_moved(event) {
        var control = event.currentTarget;
        var control_id = control.id.substring(7);
        el(control_id).value = control.value;

        // Special handling for BFO slider
        if (control_id === "BFO") {
            var currentTime = Date.now();
            var timeSinceLastAdjustment = currentTime - lastBFOAdjustmentTime;

            // Only send menu 1 if more than 5 seconds have passed since last adjustment
            if (timeSinceLastAdjustment > 5000) {
                //console.log("BFO slider: Sending menu 1 command (5+ seconds since last adjustment)");
                websocket_send("menu 1");
                // Add a slight pause between commands
                setTimeout(function() {
                    //console.log("BFO slider: Now sending BFO command");
                    websocket_send("BFO " + control.value);
                }, 200);
            } else {
                  //console.log("BFO slider: Skipping menu 1 command (last adjustment was " + Math.round(timeSinceLastAdjustment/1000) + " seconds ago)");
                websocket_send("BFO " + control.value);
            }

            // Update the last adjustment time
            lastBFOAdjustmentTime = currentTime;
        } else {
            // Normal handling for other sliders
            websocket_send(control_id + " " + control.value);
        }
    }

    //called in update from the server
    //the value is already set in the readonly control
    //we just duplicate it on the slider
    function update_linear(event) {
        event.parentNode.querySelector(".linear-slider").value = event.value;
    }

    /* close any open linear controls if clicked outside*/
    function on_click(event) {
        log("clicked");
        var target = event.target;

        //don't close if the click is within the controls slider
        if (target.classList.contains("linear-slider") ||
            target.classList.contains("linear-dropdown") ||
            target.classList.contains("linear-value"))
            return;

        var collection = document.getElementsByClassName("linear-dropdown");
        for (var i = 0; i < collection.length; i++)
            collection[i].style.display = "";
    }



    function write_console(str) {
        var con = $("#console");
        con[0].innerHTML = str;
        con.fadeIn(0);
        con.fadeOut(6000);
    }
</script>
<script>
    function setDebug(on) {
        ws.send("DEBUG:" + on);
    }

    // Function to update zerobeat display
    function updateZerobeatDisplay(value) {
        // Update the hidden input
        const hiddenInput = document.getElementById('ZEROBEAT');
        if (hiddenInput) {
            hiddenInput.value = value;
        }

        // Update the indicator boxes
        const boxes = document.querySelectorAll('.zerobeat-box');
        boxes.forEach(box => {
            const level = parseInt(box.getAttribute('data-level'));
            if (level === value) {
                box.classList.add('active');
            } else {
                box.classList.remove('active');
            }
        });
    }

    // Function to check if tune should be disabled
    function checkTuneState() {
        const tuneButton = document.getElementById('tune_button');
        const modeSelect = document.getElementById('MODE');
        const zerobeatContainer = document.getElementById('zerobeat-container');

        if (!tuneButton || !modeSelect || !zerobeatContainer) {
            console.log('Required elements not found for checkTuneState');
            return;
        }

        const disabledModes = ['CW', 'CWR', 'FT8', 'FT4'];
        const currentMode = modeSelect.value;

        if (disabledModes.includes(currentMode)) {
            tuneButton.classList.add('tune-disabled');
            tuneButton.disabled = true;

            // Show zerobeat indicator only in CW/CWR modes
            if (currentMode === 'CW' || currentMode === 'CWR') {
                zerobeatContainer.style.display = 'block';
                document.querySelectorAll('.cw-control').forEach(control => control.style.display = 'block');
            } else {
                zerobeatContainer.style.display = 'none';
                document.querySelectorAll('.cw-control').forEach(control => control.style.display = 'none');
            }
        } else {
            tuneButton.classList.remove('tune-disabled');
            tuneButton.disabled = false;
            zerobeatContainer.style.display = 'none';
        }
    }

    // Function to handle tune button click
    document.addEventListener('DOMContentLoaded', function() {
        const modeSelect = document.getElementById('MODE');

        // Listen for mode changes
        modeSelect.addEventListener('change', checkTuneState);

        // Tune button click handler   Fixed W9JES
	    const tuneButton = document.getElementById('tune_button');
	    tuneButton.addEventListener('click', function() {
		    if (isTuneOn) {
			    websocket_send('tune off');
			    isTuneOn = false;
		    } else {
			    websocket_send('tune on');
			    isTuneOn = true;
		    }
	    });

        // ePTT button handler
        document.getElementById('ePTT').addEventListener('change', function() {
            websocket_send('eptt ' + this.value.toLowerCase());
        });

        // Initialize sidetone slider
        document.getElementById('slider_SIDETONE').addEventListener('input', function() {
            websocket_send('sidetone ' + this.value);
        });

        // Check initial state to show/hide controls based on current mode
        checkTuneState();
    });

    // Hide Browser Mic button if not on HTTPS
    // Initialize NoSleep to prevent device from sleeping
    const noSleep = new NoSleep();

    // Function to enable/disable wake lock
    function enableWakeLock() {
        noSleep.enable();
        console.log('Wake Lock is enabled');
    }

    document.addEventListener('DOMContentLoaded', (event) => {
        // Enable wake lock when page loads
        enableWakeLock();

        const browserMicButton = document.getElementById('browser_mic');
        if (browserMicButton && window.location.protocol !== 'https:') {
            console.log('Not on HTTPS, hiding Browser Mic button.');
            browserMicButton.style.display = 'none';
        }

        // Auto-start browser mic if this is a remote session (not localhost/127.0.0.1)
        const isRemote = document.location.hostname !== "127.0.0.1" && document.location.hostname !== "localhost";
        if (isRemote) {
            console.log("Remote session detected, auto-starting browser microphone");
            setTimeout(function() {
                // Use the existing toggleBrowserMic function to initialize and enable the mic
                if (!window.sbitxMic.enabled) {
                    toggleBrowserMic();
                }
            }, 2000); // Small delay to ensure everything else is loaded
        }
    });
</script>

</html>
